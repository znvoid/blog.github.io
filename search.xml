<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaSE加强]]></title>
    <url>%2Fjava%2FJavaSE%E5%8A%A0%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[面向对象封装static 关键字 修饰成员变量和方法 内部类 ####特点： 随着类的加载而加载 优先于对象存在 被类的所有对象共享 可以被类名调用 优缺点： 优点: 对象共享数据，节省空间 被类名直接调用 缺点: 访问有局限性 代码块 在java中，使用{}括起来的代码被称为代码块 ####分类 #####局部代码块 在方法中出现，控制变量生命周期，及早释放，提高内存利用率 #####构造代码块 在类中方法外出现，抽取构造方法中的共性，每次创建对象都会执行，并且在构造方法前执行 #####静态代码块 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。 一般用于加载驱动 #####同步代码块 继承 多个类有共同的成员变量和方法，抽取到另一个类中（父类）在让多个类继承父类 格式：class 子类 extends 父类 {} 特点 在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类,但多个类可以继承一个父类 在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类 在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类 成员变量 子类只能获取父类的非私有成员 super 可以获取父类的成员变量和成员方法，用法与 this 相似 方法重写 当父类方法不能完成满足子类使用 用注解 @Override：方法重写，说明下面的方法是重写父类的方法 注意事项： 不能继承父类私有成员 权限修饰符必须大于等于 继承中构造方法的执行顺序A:super(实参列表);语句 在子类的构造方法中使用,用来调用父类中的构造方法(具体哪一个由传递的参数决定),并且只能在构造方法第一行使用 B:this(实参列表); 语句 在类的构造方法中使用,用来调用本类中的其它构造方法(具体哪一个由传递的参数决定),并且只能在构造方法的第一行使用 匿名对象没有变量引用的对象 当方法只调用一次时使用 final关键字final： 修饰符，可以用于修饰类、成员方法和成员变量 final所修饰的类：不能被继承，不能有子类 final所修饰的方法:不能被重写 final所修饰的变量：是不可以修改的，是常量 抽象类abstract 修饰符 用于方法和类 有抽象方法的类必须是抽象类 抽象类的特点： 抽象方法只能在抽象类里面 抽象类和抽象方法必须被abstract修饰 抽象类不能创建对象（不能实例化） 抽象类中可以有非抽象的方法 抽象类和类的关系也是继承 一个类继承了抽象类要么重写所有的抽象方法，要么他自己是抽象类 static 修饰的方法不会被继承 接口处理单一继承的局限性 比抽象类还抽象的类，接口里所有的方法都是抽象方法，接口和类的关系是实现 implements 定义格式：public interface 接口名 { 抽象方法1; 抽象方法2; } 使用class 类 implements 接口 { 重写接口中方法 } 特点只能有抽象方法 方法只能使用pulic abstract 修饰符 默认使用 可省略 只能有常量 常量只能使用pulic static fianl 修饰符 默认使用 可省略 类与接口关系类与类之间:继承关系,一个类只能直接继承一个父类,但是支持多重继承 类与接口之间:只有实现关系,一个类可以实现多个接口 接口与接口之间:只有继承关系,可以多重继承 优点打破继承的局限性 对外提供规则 降低了程序的耦合性 接口和抽象类的区别1.共性： 不断的进行抽取，抽取出抽象的，没有具体实现的方法,都不能实例化（不能创建对象） 2.区别 与类的关系 类与接口是实现关系，而且是多实现，一个类可以实现多个接口，类与抽象类是继承关系，Java中的继承是单一继承，多层继承，一个类只能继承一个父类，但是可以有爷爷类 成员 a.成员变量 抽象类可以有成员变量，也可以有常量 接口只能有常量，默认修饰符public static final b.成员方法 抽象类可以有抽象方法，也可以有非抽象方法 接口只能有抽象方法，默认修饰符 public abstract c.构造方法 抽象类有构造方法，为子类提供 接口没有构造方法 多态 多态是继封装、继承之后，面向对象的第三大特性 前提 子父类 方法重写 父类引用指向子类对象 动态绑定 运行期方法调用是根据其具体类 优点 可维护性 可扩展性 包：多层结构 不同包下文件名可相同 必须在第一行声明 类的全名 包名.类名 使用import 类的全名 将类导入 修饰符 权限修饰符 public protected default private 同一类中 √ √ √ √ 同一包中(子类与无关类) √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 修饰符 类 成员变量 成员方法 构造方法 public Y Y Y Y default Y Y Y Y protected Y Y Y private Y Y Y abstract Y Y static Y Y final Y Y Y 内部类 将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。其他类也称为外部类。 成员内部类在类的成员位置 可以访问外部类的成员包括私有成员 外部类.内部类 对象名 = new 外部类().new 内部类(); 局部内部类 在方法内，出了方法就无法使用 匿名内部类可以看做没有名字的局部内部类 格式 new 类/接口 (){ 有抽象方法就必须实现具体方法体 }; 原理： 创建了这个类（接口）的子类对象 APIObject 类层次结构的根类 ###方法 12toString()equals(Object obj) System 不能被实例化 包含一些有用的字段和方法 方法123456789arraycopy(Object src, int srcPos, Object dest, int destPos, int length)从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。currentTimeMillis() 返回以毫秒为单位的当前时间 exit(int status) 终止当前正在运行的 Java 虚拟机 Date 表示特定的瞬间，精确到毫秒 构造函数Date() 创建当前系统时间的Date对象 Date(long date) 创建指定时间的Date对象 方法 setTime(long time) long getTime() 大部分方法已过时 Calendar类代替 DateFormat 抽象类 已知实现子类SimpleDateFormat SimpleDateFormat构造函数SimpleDateFormat() 默认模式创建对象 SimpleDateFormat(String pattern)指定模式创建对象 方法Date parse(String text)解析字符串的文本，生成 Date。 String format(Date date) 将给定的 Date 格式化为日期/时间字符串。 12345678 例： SimpleDateFormatsdf = new SimpleDateFormat("yyyy年MM月dd日HH:mm:ss");Date date = new Date();String s = sdf.format(date)-----------------String now = "2000-01-01"；SimpleDateFormatsdf = new SimpleDateFormat("yyyy-MM-dd")Date d2 = sdf.parse(now); Calendar抽象类 已知实现子类GregorianCalendar Calendar c = Calendar.getInstance(); c.get(Calendar.DAY_OF_MONTH ) 包装类由于基本数据类型只能做一些简单的操作和运算，所以java为我们封装了基本类型。 自动装箱和拆箱 从JDK1.5 开始 正则表达式一套规则可以用于比配字符串 Pattern Matcher 字符 x 字符 x \\ 反斜线字符 字符类 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） 预定义字符类 . 任何字符（与行结束符可能匹配也可能不匹配） \d 数字：[0-9] \D 非数字： [^0-9] \s 空白字符：[ \t\n\x0B\f\r] \S 非空白字符：[^\s] \w 单词字符：[a-zA-Z_0-9] \W 非单词字符：[^\w] 数量词 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 集合Collection基本概念接口Collection 层次结构的根1234boolean add(E e)void clear()boolean contains(Object o)boolean isEmpty() 遍历方式1、toArray() 把集合变成数组，然后遍历数组 2、iterator() 迭代器对象，通过迭代器对象迭代集合 Iterator 类 Object next() 下一个元素 boolean hasNext() 判断是否有下一个元素 增强for循环for(元素类型 元素变量：集合或数组对象){ 可以直接使用元素变量 } 在增强for循环中不能修改集合，否则会发生并发异常 并发修改异常在使用迭代器是不允许集合有修改（增加、删除），否则会抛出异常 解决办法 使用迭代器自身去修改集合 ##泛型 是一种广泛的类型，把明确数据类型的工作提前到了编译时期，借鉴了数组的特点 特别注意：泛型只能写引用数据类型。 泛型的好处 避免了类型转换的问题 可以减少黄色警告线 可以简化我们代码的书写 类名上的泛型class Box&lt;E&gt;{} 方法上的泛型public &lt;T&gt; T method(T t){ return t; } 泛型上下限? extends 类名1 泛型上限 ？ super 类名2 泛型下限 常见数据结构数组： 长度一旦定义就不能改变 有整数索引 只能存储同一种类型的元素 即可以存储基本数据类型也可以存储引用数据类型 查找快 增删慢 链表 由链子连接起来的一堆节点 特点:查询慢 增删快 栈 先进后出 队列 先进先出 List有序 存储顺序有序 索引 允许重复 子类 ArrayList 底层是数组结构 查询快 增删慢 LinkedList 底层是链表结构 查询慢 增删快 方法 addFirst(E e) getFirst() removeFirst() addLast(E e) getLast() removeLast() HashSetList的子类 无序（存储和读取的顺序） 元素唯一 Collections 集合工具类 方法1234567891011int binarySearch(List list,T key) //二分查找指定元素的下标,注意list必须排序完毕 copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) // 把源列表数据覆盖到目标列表，注意目标列表的长度至少必须等于源列表fill(List&lt;? super T&gt; list, T obj) //使用指定元素替换指定列表中的所有元素 shuffle(List&lt;?&gt; list) //使用默认随机源对指定列表进行置换。 sort(List&lt;T&gt; list) //根据元素的自然顺序 对指定列表按升序进行排序。 swap(List&lt;?&gt; list, int i, int j) //在指定列表的指定位置处交换元素。 Map 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 与Collextion的区别 Map : 双列集合 通常处理有对应关系的数据 key是不可重复的 Collection: 单列集合，有不同子类体系 常用功能 增 put(key ,value) 删 clear() 清除所有 remove(Object e) 移除 查 get(Object key) 异常 包含错误的类型、原因、位置 ##体系结构 123graph TDThrowable--&gt;ErrorThrowable--&gt;Exception 处理方式 出现异常未处理 jvm帮我们处理 控制台打印异常信息并终止程序 捕获处理 try ... catch try{ 可能出现问题的代码 }catch(异常类 异常){ } 抛出去 12345678 方法（） throws 异常类 &#123;&#125;新 try(FileWriter fw = new FileWriter(&quot;a.txt&quot;))&#123;//自动关流 fw.write(&quot;&quot;); &#125;catch(Exception e)&#123; &#125; 异常种类###运行时异常 RuntimeException 的子类，在运行时期的异常 编译时异常 Exception子类RuntimeException子类非编译时期必须处理 IO流File类构造方法123File(File parent,String child)File(String path)File(String parent,String child) 方法12345creatNewFile() //创建文件mkdir() //创建文件夹mkdirs()delete() //删除文件，isAbsolute() 路径是否是绝对路径 分类标准输入输出流 System.in System.out 转换流 把字节流转换为字符流 outputStreamWriter inputStreamReader 打印流 打印流添加输出数据的功能，使它们能够方便地打印各种数据值表示形式. 字符打印流 PrintWriter void print(String str): 输出任意类型的数据， void println(String str): 输出任意类型的数据，自动写入换行操作 对象流 用于从流中读取对象的 ObjectInputStream称为 反序列化流,利用输入流从文件中读取对象 ObjectOutputStream 称为 序列化流,利用输出流向文件中写入对象 特点：用于操作对象。可以将对象写入到文件中，也可以从文件中读取对象。 多线程概念进程：一个应用程序在内存中执行区域线程：进程中的一个执行控制单元 一个进程可以有多个线程 多线程实现 方式一 继承Thread 类 重写run方法 创建对象 启动 start() 方式二 实现Runnable 接口 网络 设备之间的数据通讯 Socket 三要素ip 网络设备的标识 端口 用于标识进程的逻辑地址 传输协议 udp tcp ip InerAddress表示网络协议（IP) 地址 InetAddress address =InetAddress.getByName(&quot;itheima&quot;);//通过主机名获取InetAddress InetAddress address =InetAddress.getLocalHost();//本地主机InetAddress Udp发送过程1234567891011121314 //创建Socket对象 DatagramSocket ds =new DategramSocket();//创建socket对象随机分配端口 //DatagramSocket ds =new DategramSocket(1000);指定端口 //创建数据并打包 //DatagramPacket 数据包类 byte[] bys;//数据 InetAddress addr = InetAddress.getByName("");//ip地址 int port ;//端口 DatagramPacket dp = new DatagramPacket(bys,bys.length,addr,port); // 发送数据 ds.send(dp); //关闭资源 ds.close(); 接收过程1234567891011121314 //创建Socket对象 DatagramSocket ds =new DategramSocket(1000);//指定端口//接收数据byte[] bys = new byte[1024];DatagramPacket dp = new DatagrmPacket(bys,bys.length);ds.receive(dp);//拆分数据InetAddress addr =dp.getAddress();int length =dp.getLength();//数据长度//byte[] data =dp.getData();//数据会在bys 中//关闭资源ds.close(); Tcp发送123456789 //创建socket对象 Socket socket = new Socket(InetAddres.getByName(""),10086);// 获取输出流对象OutputSteam os socket.getOutputStream();// 发送数据 os.write(""); //关闭资源 socket.close(); 接收12345678910 ServerSocket ss = new ServerSocket(10086); //监听Socket socket = ss.accept();//获得输入流InputStream is =socket.getInputStream();byte[] bs = new byte[1024];int len =is.read(bs);is.close(); 反射 运行过程中获取对象，对象中的成员 获取字节码对象Class clz =Class.forName(&quot;类的全名&quot;); 获取构造方法Constructor[] cs= clz.getConstructors() //获取所有public 构造方法 Constructor c =clz.getConstructor();//获取无参构造 Constructor c =clz.getConstructor(T.class,..);//获取有参构造 创建对象Object o = c.newInstance();//无参 c为无构造 Object o = c.newInstance(...);//有参 传递实参 c为有参构造 获取成员字段Field field =clz.getField(); Field[] getFields(); public 字段 getDeclarefields(); 所有的字段 field.get(o) //获取o对象上的field字段的值 field.setAccessible(true) //设置反射取消java访问检查 field.set(o,值) //给o对象上的field字段设值 获取成员方法Method m = clz.getMethod(&quot;method&quot;,形参类型); m.Invoke(o,实参); 调用方法]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>进阶学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础]]></title>
    <url>%2Fjava%2FJavaSE%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JavaSE基础##环境搭建 安装JDK配置环境变量JVM JRE =JVM +类库 JDK =JRE+java开发工具 数据类型：基本数据类型 整数 byte 一个字节 short 两个字节 int 四个字节 long 八个字节 小数 float 4个字节 double 8个字节 字符 char 2个字节 布尔 boolean float double 在内存中存放结构 float一共32位，其结构定义如下： |—— 31 —–|—- 30-23 —— |—— 22-0 —–| 符号位(sign) 指数部分(exp) 小数部分(mag) sign:符号位就一位，0表示正数，1表示负数 exp: 指数部分，无符号正数 mag:小数部分，定点小数，小数点在最左边。 float的表达式 : pow(-1,sign) (1+mag) pow(2,exp-127) 引用数据类型数组 对象(new出来的) 需要注意的 1234byte a=10,b=20;byte c=a+b;//编译通不过，byte short char 做+、-、*、/运算时结果为int类型byte b = 3;//java有常量优化机制 , 3 为常量 在取值范围内jvm会自动强制转换 常量、变量 变量定义格式 数据类型 变量名 = 初始化值； 例： int a=10; 算数运算+ - * / % ++ -- 逻辑运算&amp; | ！ ^ &amp;&amp; || 三元运算符关系表达式？表达式1：表达式2； int c=a&gt;b?a:b; 不能单独存在,结果必须被接收 条件语句12345678if(条件)&#123;&#125;switch()&#123; case 值: break; default: break;&#125; 循环语句123456for(;;)&#123;&#125;while()&#123;&#125;do&#123;&#125;while(); 跳转语句 break continue return 数组声明数组：数据类型[] 数组名； 数组赋值： 数组名=new 数组类型[数组长度]； 数组名=new 数组类型[]{数据1，数据2，…}； 数组进行初始化 a:动态初始化 只指定长度，由系统给出初始化值 int[] arr = new int[5]; b:静态初始化 给出初始化值，由系统决定长度 int[] arr = new int[]{1,2,3,4,5}; 简写：int[] arr = {1,2,3,4,5}; c 不能动静结合的初始化 如int[] arr = new int[5]{1,2,3,4,5};编译不会通过1234//例子：int[] arr =new int[5];//动态初始化int arr =new int[]&#123;1,2,3,4,5&#125;;//静态初始化int arr =new int[5]&#123;1,2,3,4,5&#125;; //错误的表示编译报错 二维、多维数组 int[][] arr=new int[m][n]; 排序 冒泡排序123456789for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j+1 &lt; arr.length-i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; int temp =arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125;&#125; *选择排序123456789for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i+1; j &lt; arr.length; j++) &#123; if (arr[i] &gt; arr[j]) &#123; int temp =arr[i]; arr[i] =arr[j]; arr[j] = temp; &#125; &#125;&#125; 方法（函数）定义： 声明：大括号前面的内容 内容：大括号里面的内容 修饰符 返回类型 方法名（参数类型 参数1，参数类型 参数2....）{ //return ;//当返回类型为void 是可以省略，可以不带值 return 返回值；//返回值的类型必须与返回类型匹配 } 面向对象 面向过程:一步一步的执行 强调过程 面向对象:是一种思想基于面向过程的 将过程封装起来是一种更符合我们思考习惯的思想复杂变简单执行者变成指挥者 Java语言最基本的单位-类 类：是一组相关的属性和行为的集合 对象：就是该事物的具体体现 三大特性 封装 将不需要对外提供的内容都隐藏起来 继承 多态 构造方法 与类名一致 不写返回值类型 1234class Person&#123; public Person()&#123;//构造方法 &#125;&#125; javaBean规范 空参构造 属性私有化 提供setXXX(…) getXXX() API 应用程序接口 String类构造方法123String(String original)String(char[] value)String(char[],int index,int count)//把字符数组的一部分变成字符串对象 字符串的内容存储在方法区的常量池中的，方便字符串的重复使用 常用方法1234boolean equals(Object obj):比较字符串的内容是否相同boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写boolean startsWith(String str):判断字符串对象是否以指定的str开头boolean endsWith(String str):判断字符串对象是否以指定的str结尾 StringBulider类IO流 可以把数据存储到文件也可以从文件中读取数据 分类 按方向： 输入流 输出流 按功能： 节点流 处理流 按数据 字节流 字符流FileWriter 类构造方法 123FileWriter(File file)FileWriter(String fileName)FileWriter(String fileName,boolean flag) //flag表示是否在文件末尾追加写入 默认false 常用方法123456write(String str) //写字符串wirte(String str,int index,int len)write(char ch)wirte(char ch,int index,int len)flush() //刷新close() //关闭流释放资源，流将不能再使用了 使用步骤 创建对象，关联文件 调用输出流对象的写数据方法write(String str) 关闭资源1234//例子：FileWrite fw =new FileWriter("D:\\a.txt");fw.write("IO流");fw.close(); 换行符window : \r\n linux :\n max :\r FileReader类构造方法12FileReader(Flie flie)FileReader(String fileName) 常用方法12int read();close() 使用步骤 创建输入流对象 调用输人流对象的读数据方法read() 关闭释放资源1234例子：FileReader fr =new FileReader (&quot;D:\\a.txt&quot;);int a = fr.read();fr.close(); BufferedWriter 类 高效的写字符输出流构造方法1BufferedWriter(FileWriter fileWriter) 常用方法1234write(String s)flush();close()newLine(); //写一个换行符 12345//例子BufferedWriter bw = new BufferedWriter(new FileWriter("a.txt"));bw.wirte("abv")bw.flush();bw.close(); BufferedReader类 高效的文本读取构造方法1BufferedReader(FileReader fr) 常用方法1234read()flush();close()readLine() 一次读一行字符不包括换行符 12345//例子BufferedReader br = new BufferedReader(new FileReader("a.txt"));int c = bw.read()bw.flush();bw.close();]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2FMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[xml]]></title>
    <url>%2FjavaWeb%2Fxml%2F</url>
    <content type="text"><![CDATA[什么是xml可扩展标记语言 功能传输和存储数据 软件的配置文件 使用xml语法基本语法:- XML必须有关闭标签 - 区分大小写 - 属性需要有引号 - 标签必须正确嵌套. 文档声明 注释 元素 属性 特殊字符和CDATA区 文档声明通常出现在xml 文档的第一行第一列12345&lt;?xml 属性名=&quot;值&quot; ... ?&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;* version :必须的. 使用”1.0”* encoding :字符集. 是使用浏览器打开的时候采用的默认的字符集的编码.* standalone :描述XML文档是否需要依赖其他的文件. 注释&lt;!-- 注释内容 --&gt; 元素(标签)命名规范 字母 数字 及其他字符 不能以数字或标点符号开始 不能以字符”xml”(“XML/Xml”)开始 不能包含空格 属性属性的名称规范与元素一致 需要引号 特殊字符和CDATA区#####特殊字符 &amp;lt; &lt; 小于 &amp;gt; &gt; 大于 &amp;amp; &amp; 和号 &amp;apos; &apos; 单引号 &amp;quot; &quot; 引号 CDATA区CDATA区中的所有内容都会被认为是字符串1&lt;![CDATA[ 内容 ]]&gt; xml解析从xml文档中获取数据 解析方式 DOM解析 Doucument Object Model SAX解析 Simple Api for Xml 两种解析方式的区别DOM: 一次性将文档加载到内存形成树形结构解析 优点:当文件特别大时容易内存溢出 缺点:对xml进行增删改操作 SAX: 事件驱动方式,一行一行的解析 优点:不能对文档进行增删改操作 缺点:当文件特别大时不会内存溢出 api实现与案例针对这两种解析的方式，不同的公司提供了不同的API的实现. JAXP :SUN公司提供的一套XML的解析的API. JDOM :开源组织提供了一套XML的解析的API-jdom. DOM4J :开源组织提供了一套XML的解析的API-dom4j. pull :主要应用在Android手机端解析XML. dom4j案例代码 【步骤一】导入jar包.dom4j-1.6.1.jar 【步骤二】创建解析器 【步骤三】解析文档获得代表文档的Document对象. 【步骤四】获得跟节点. 【步骤五】从跟节点下查找其他的节点 12345678910111213141516// 创建解析器SAXReader reader = new SAXReader();// 解析XML的文档Document document = reader.read("xml/demo1.xml");// 获得跟节点Element root = document.getRootElement();System.out.println(root.getName());// 查找跟节点下的子节点. element() elements();Element pElement = root.element("person"); // 查找的是第一个person元素// root.elements("person").get(1); // 查找的是第二个person元素Element nElement = pElement.element("name");Element aElement = pElement.element("age");Element sElement = pElement.element("sex");System.out.println(nElement.getText());System.out.println(aElement.getText());System.out.println(sElement.getText()); XPathXPath由W3C的XPath 1.0 标准描述,dom4j支持xpath jaxen-1.1-beta-6.jar dom4j的XPath支持的API: List document.selectNodes(String xPath); Node document.selectSingleNode(String xPath);1234567891011121314// 创建解析器: SAXReader reader = new SAXReader(); // 解析XML返回Document对象. Document document = reader.read("xml/demo1.xml"); /*List&lt;Node&gt; list = document.selectNodes("//name"); for (Node node : list) &#123; Element element = (Element) node; System.out.println(element.getText()); &#125;*/ List&lt;Node&gt; list = document.selectNodes("//person['@id']"); for (Node node : list) &#123; Element element = (Element) node; System.out.println(element.attributeValue("id")); &#125; xml约束XML的约束的概述: 什么是XML的约束 :就是用来约束XML的文档中可以出现哪些标签，不能出现哪些标签，标签中是否有顺序，出现的次数. XML的约束 :用来规范XML的写法 ###XML的约束的种类及区别?DTD 和 Schema : 区别: 1.DTD语法是自成一体的.Schema语法就是XML的语法. 2.Schema的语法就是XML的语法所以更容易被解析器所解析. 3.Schema支持名称空间. 4.Schema有比DTD更加强大的语义和语法的约束. DTD的语法####DTD的引入方式: 内部的DTD:&lt;!DOCTYPE persons []&gt; 外部的DTD: 一种本地DTD:&lt;!DOCTYPE persons SYSTEM “unknown.dtd”&gt; 一种网络DTD:&lt;!DOCTYPE persons PUBLIC “//UNKNOWN/“ “unknown.dtd”&gt; 元素: &lt;!ELEMENT 元素名 元素类型&gt; 元素类型: EMPTY ANY 子元素 是否有序: 使用 逗号(,)或者竖线(|)表示. 出现的次数：?:零次或一次 +：一次或多次 *：零次或多次 PCDATA 可解析的字符串 属性: &lt;!ATTLIST 元素名称 属性名称 属性的类型 属性的约束&gt; 属性的类型: ID类型:表示属性值需要是唯一的. CDATA类型:普通的字符串. 枚举: 属性的约束: #REQUIRED 属性值是必须的 #IMPLIED 属性不是必须的 #FIXED value 属性值固定12345678&lt;!ELEMENT persons (person*)&gt;&lt;!ELEMENT person (name|age|sex)*&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT age (#PCDATA)&gt;&lt;!ELEMENT sex (#PCDATA)&gt;&lt;!ATTLIST person id ID #REQUIRED&gt; Schema的语法12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 名称空间:一个XML只能引入一个DTD约束文档.使用了Schema约束XML文档,一个XML可以引入多个Schame的约束!!! 如果再多个Schema文档中定义了相同的属性名称 该怎么办? * 名称空间类似于java中的package.通过名称空间区分 标签或属性来自于哪个文档的！！！通常名称空间唯一的不重复的即可.一般情况下使用一个URL地址表示一个名称空间. xmlns :xml name sapace .代表当前的文档应用的名称空间. targetNameSpace :目标名称空间. elementFormDefault : --&gt;&lt;schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.itheima.com/ee25" elementFormDefault="qualified"&gt; &lt;!-- 复杂标签 --&gt; &lt;element name="persons"&gt; &lt;!-- 复杂类型 --&gt; &lt;complexType&gt; &lt;sequence maxOccurs="unbounded" minOccurs="1"&gt; &lt;element name="person"&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;!-- 简单标签 --&gt; &lt;element name="name" type="string"&gt;&lt;/element&gt; &lt;element name="age" type="int"&gt;&lt;/element&gt; &lt;element name="sex" type="string"&gt;&lt;/element&gt; &lt;/sequence&gt; &lt;attribute name="id" type="string" use="required"/&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt;&lt;/schema&gt;]]></content>
      <categories>
        <category>javaWeb</category>
      </categories>
      <tags>
        <tag>xml</tag>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站主题设置]]></title>
    <url>%2F%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%2F%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[动态背景 修改 _layout.swig 主题文件下/layout/_layout.swig 在 &lt;\/body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面) 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 修改主题配置文件 打开 主题下的_config.yml,在里面添加如下代码：(可以放在最后面)123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 主页文章阴影效果打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 在网站底部加上访问量编辑 主题配置文件 中的busuanzi_count的配置项。 当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。 \themes\next\layout_partials\footer.swig文件,在copyright前加上画红线这句话：1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后添加显示统计的代码123456&lt;!-- 放在&lt;div class=&quot;powered-by&quot;&gt; 前--&gt;&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 首页只显示文章部分 修改 _config.yml文件123auto_excerpt: enable: true length: 150 页脚元素居中修改your blog\themes\next\source\css\schemes\Mist\index.styl文件，将.footer-inner中的text-align: left;修改为text-align: center;即可。 修改文章内链接文本样式修改文件 themes\next\source\css\_common\components\post\post.styl ，在末尾添加如下css样式，： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; blog文章书写开头格式1234567891011title: # 文章标题author: # 作者tags: - Hexo - Nextcategories: - Hexo - Nextdescription: # 描述，首页文章显示的摘要date: --- 关闭侧边栏设置在\source\js\src\motion.js里自行写实现该效果的js方法（当然也可以放在页面其他js文件里面）： 这里贴一个实现此需求的js方法： // $(‘.sidebar-inner’).css({‘height’:’100%’});$(‘body’).on(‘click’,function(e){ var bSidebarShow = $(‘#sidebar’).css(‘display’)===’block’ &amp;&amp; $(‘#sidebar’).width() &gt; 0; var bFlag = $(e.target).parents(‘#sidebar,.sidebar-toggle’).length &gt; 0; if(bSidebarShow &amp;&amp; !bFlag){ $(‘.sidebar-toggle-line-wrap’).trigger(‘click’); e.preventDefault(); }}); 侧边栏居左 修改 source\js\src\motion.js使用Ctrl+F查找paddingRight 把其修改为paddingLeft就可以了 source\css_custom下为custom.styl添加内容123456 .sidebar-toggle&#123; left:30px;&#125;.sidebar&#123; left:0;&#125; 把back-to-top这个按钮留在了右侧如果你偏向一并放在左侧 添加以下css123.back-to-top&#123; left:30px;&#125; 修改箭头动画方向修改motion.js文件123456789101112131415161718192021var sidebarToggleLine1st = new SidebarToggleLine(&#123; el: '.sidebar-toggle-line-first', status: &#123; arrow: &#123;width: '60%', rotateZ: '45deg', top: '2px', left: '50%'&#125;, close: &#123;width: '100%', rotateZ: '-45deg', top: '5px'&#125; &#125;&#125;);var sidebarToggleLine2nd = new SidebarToggleLine(&#123; el: '.sidebar-toggle-line-middle', status: &#123; arrow: &#123;width: '90%'&#125;, close: &#123;opacity: 0&#125; &#125;&#125;);var sidebarToggleLine3rd = new SidebarToggleLine(&#123; el: '.sidebar-toggle-line-last', status: &#123; arrow: &#123;width: '60%', rotateZ: '-45deg', top: '-2px', left: '50%'&#125;, close: &#123;width: '100%', rotateZ: '45deg', top: '-5px'&#125; &#125;&#125;); 不能调整透明就把motion.js中选择的两个body改成了.containerNexT.utils.isDesktop() &amp;&amp; $(‘.container’).velocity(‘stop’) 侧栏背景图以及内部文字颜色的修改在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：1234567#sidebar &#123; background:url(图片链接); background-size: cover; background-position:center; background-repeat:no-repeat; p,span,a &#123;color: 颜色代码;&#125;&#125; 滑动的menumenu中的搜索LocalSearch搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： $ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： Local search local_search: enable: true]]></content>
      <categories>
        <category>网站搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog网站搭建]]></title>
    <url>%2F%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%2F%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[准备 Node.js Git Hexo github账号 安装node.js官网 安装Git直接到Git官网 下载安装即可 安装Hexo 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装好Node.js与Git 执行命令 1npm install -g hexo-cli 初始化随便建一个文件夹，名字随便取，博主取其名为blog，cd 到文件夹里，先安装必要的文件，执行以下命令：12hexo init # hexo会在目标文件夹建立网站所需要的所有文件npm install # 安装依赖包 本地启动有了必要的各种配置文件之后就可以在本地预览效果了12hexo g # 等同于hexo generate，生成静态文件hexo s # 等同于hexo server，在本地服务器运行 打开浏览器并输入IP地址 http://localhost:4000/ 查看 简单的命令总结一下简单的使用命令1234567hexo init [folder] # 初始化一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站hexo new [layout] &lt;title&gt; # 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来hexo version # 查看版本hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g # 等于hexo generate # 生成静态文件hexo s # 等于hexo server # 本地预览hexo d # 等于hexo deploy # 部署，可与hexo g合并为 hexo d -g 安装主题git克隆Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可使用git克隆最新版next主题12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题打开站点配置文件， 找到 theme 字段，并将其值更改为 next1theme: next 然后 hexo s 即可预览主题效果 更换主题外观NexT有三个外观，博主用的是 Muse，直接更改主题配置文件的 scheme 参数即可，如果显示的是繁体中文，那么站点配置文件中的 language: zh-CN123scheme: Muse#scheme: Mist#scheme: Pisces 注册Github部署到Github与Coding在此之前，先安装Git部署插件1npm install hexo-deployer-git --save 打开站点配置文件，拉到底部，修改部署配置：1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:masteranthoneyd/masteranthoneyd.github.io.git,master coding: git@git.coding.net:ookamiantd/ookamiantd.git,master 终端执行123hexo cleanhexo ghexo d 绑定域名]]></content>
      <categories>
        <category>网站搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
