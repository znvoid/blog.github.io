<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring一]]></title>
    <url>%2FJavaWeb%2FSping%E6%A1%86%E6%9E%B6%2FSpring%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Spring Spring 是一个开源框架,一个分层的 JavaSE/EEfull-stack(一站式) 轻量级开源框架 体系结构 核心容器 Core 和 Beans 模块提供了 Spring 最基础的功能，提供 IoC 和依赖注入特性。这里的基础概念是 BeanFactory，它提供对 Factory 模式的经典实现来消除对程序性单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置。 Context 模块基于 Core 和 Beans 来构建，它提供了用一种框架风格的方式来访问对象，有些像 JNDI 注册表。Context 封装包继承了 beans 包的功能，还增加了国际化（I18N）,事件传播，资源装载，以及透明创建上下文，例如通过 servlet 容器，以及对大量 JavaEE 特性的支持，如 EJB、JMX。核心接口是 ApplicationContext。 Expression Language，表达式语言模块，提供了在运行期间查询和操作对象图的强大能力。支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。 数据访问/ 集成部分(Data Access/Integration) JDBC 模块，提供对 JDBC 的抽象，它可消除冗长的 JDBC 编码和解析数据库厂商特有的错误代码。 ORM 模块，提供了常用的”对象/关系”映射 API 的集成层。 其中包括 JPA、JDO、Hibernate和 iBatis 。利用 ORM 封装包，可以混合使用所有 Spring 提供的特性进行”对象/关系”映射，如简单声明性 事务管理 OXM 模块，提供一个支持 Object 和 XML 进行映射的抽象层，其中包括 JAXB、Castor、XMLBeans、JiBX 和 XStream。 JMS 模块，提供一套”消息生产者、消费者”模板用于更加简单的使用 JMS，JMS 用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 Transaction 模块，支持程序通过简单声明性 事务管理，只要是 Spring 管理对象都能得到Spring 管理事务的好处，即使是 POJO，也可以为他们提供事务 Web Web-Socket 模块， WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，spring 支持 webSocket 通信。 Web 模块，提供了基础的 web 功能。例如多文件上传、集成 IoC 容器、远程过程访问、以及 Web Service 支持，并提供一个 RestTemplate 类来提供方便的 Restful services 访问 Web-Servlet 模块，提供了 Web 应用的 Model-View-Controller（MVC）实现。Spring MVC框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的JSP 标签，完全无缝与 Spring 其他技术协作。 Web-Portlet 模块，提供了在 Portlet 环境下的 MVC 实现 AOP AOP 模块，提供了符合 AOP 联盟规范的面向方面的编程实现，让你可以定义如方法拦截器和切入点，从逻辑上讲，可以减弱代码的功能耦合，清晰的被分离开。而且，利用源码级的元数据功能，还可以将各种行为信息合并到你的代码中 。 Aspects 模块，提供了对 AspectJ 的集成。 Instrumentation 模块， 提供一些类级的工具支持和 ClassLoader 级的实现，可以在一些特定的应用服务器中使用 Test Test 模块，提供对使用 JUnit 和 TestNG 来测试 Spring 组件的支持，它提供一致的ApplicationContexts 并缓存这些上下文，它还能提供一些 mock 对象，使得你可以独立的测试代码。 特点 方便解耦，简化开发 Spring 就是一个大工厂，可以将所有对象创建和依赖关系维护，交给 Spring 管理 AOP 编程的支持 Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 声明式事务的支持 只需要通过配置就可以完成对事务的管理，而无需手动编程 方便程序的测试 Spring 对 Junit4 支持，可以通过注解方便的测试 Spring 程序 方便集成各种优秀框架 Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持 降低 JavaEE API 的使用难度 Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等），都提供了封装，使这些 API 应用难度大大降低 IOC与DI IOC inversion of Controller 控制反转。在程序中所说的 IOC 其实简单说，就是原来由我们自己实例化的对象交给 spring 容器来实始化 DI:dependency injection 依赖注入在 spring 框架负责创建 Bean 对象时，动态将依赖对象注入到 Bean 组件 spring开发环境搭建 在spring开发中，根据不同的情况来导入不同的 jar 包 commons-logging-1.2.jar log4j-1.2.16.jar spring-aop-4.2.4.RELEASE.jar spring-beans-4.2.4.RELEASE.jar spring-context-4.2.4.RELEASE.jar spring-core-4.2.4.RELEASE.jar spring-expression-4.2.4.RELEASE.jar spring-test-4.2.4.RELEASE.jar 配置文件 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- &lt;bean id="userService" class="com.znvoid.domain.UserServiceImpl"&gt; &lt;/bean&gt; &lt;bean id="user" class="com.znvoid.domain.User"&gt; &lt;property name="username" value="tom"/&gt; &lt;property name="password" value="123"/&gt; &lt;/bean&gt; --&gt;&lt;!-- 下面的配置作用是指定spring扫描的包,它包含了context:annotation-config的功能，所以在开发中一般就不需要在配置上面的 --&gt;&lt;!--&lt;context:component-scan base-package="com.znvoid.domain" /&gt;--&gt;&lt;/beans&gt; Bean 获取与实例化 ApplicationContext 它是扩展 BeanFactory 接口。BeanFactory 它采取延迟加载的方案，只有真正在 getBean 时才会实例化 Bean在开发中我们一般使用的是 ApplicationContext,真正使用的是其实现类,FileSystemXmlAppliCationContext 根据文件路径获取ClassPathXmlApplicationContext 根据类路径获取AppliCationContext它会在配置文件加载时，就会初始化Bean,并且ApplicationContext它 提 供 不 同 的 应 用 层 的 Context 实 现 。 例 如 在 web 开 发 中 可 以 使 用WebApplicationContext. bean的作用域 在 bean 声明时它有一个 scope 属性，它是用于描述 bean 的作用域 singleton:单例 代表在 spring ioc 容器中只有一个 Bean 实例 (默认的 scope) prototype 多例 每一次从 spring 容器中获取时，都会返回一个新的实例 request 用在 web 开发中，将 bean 对象 request.setAttribute()存储到 request 域中 session 用在 web 开发中，将 bean 对象 session.setAttribute()存储到 session 域中 生命周期 instantiate bean 对象实例化 populate properties 封装属性 如果 Bean 实现 BeanNameAware 执行 setBeanName 如果 Bean 实现 BeanFactoryAwar 或 ApplicationContextAwar 设置工厂setBeanFactory 或上下文对象 setApplicationContext 如果存在类实现 BeanPostProcess(后处理 Bean),执行 postProcessBeforeInitialization 如果 Bean 实现 InitializingBean 执行 afterPropertiesSet 调用自定义的 init-method 方法 如果存在类实现 BeanPostProcessor(处理 Bean),执行 postProcessAfterInitialization 执行业务处理 如果 Bean 实现 DisposableBean 执行 destroy 调用自定义的 destroy-method 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//bean类public class BeanLifeCycle implements BeanNameAware, ApplicationContextAware, InitializingBean, DisposableBean &#123; private String name; public BeanLifeCycle() &#123; System.out.println("第一步:实例化BeanLifeCycle对象"); &#125; // 自定义功能 public void add() &#123; System.out.println("第九步:自定义功能add....."); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; System.out.println("第二步:属性name的注入" + name); this.name = name; &#125; @Override public void setBeanName(String name) &#123; System.out.println("第三步:得到bean的id或name值:" + name); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; System.out.println("第四步:得到ApplicationContext对象:" + applicationContext); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println("第六步:属性注入完成后"); &#125; public void myInit() &#123; System.out.println("第七步:自定义的init方法"); &#125; @Override public void destroy() throws Exception &#123; System.out.println("第十步:执行destroy方法"); &#125; public void myDestroy() &#123; System.out.println("第十一步:执行自定义的销毁方法"); &#125;&#125;//BeanPostProcess实现，配置后对所有的bean有效public class MyBeanPostProcess implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("第五步:beanPostProcessor的before方法"); System.out.println("处理的bean是" + bean + " 它的名称是" + beanName); return bean; &#125; @Override public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException &#123; System.out.println("第八步:beanPostProcessor的after方法"); return bean; &#125;&#125;//测试 ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml"); BeanLifeCycle beanLife = (BeanLifeCycle) applicationContext.getBean("beanLifeCycle"); beanLife.add(); applicationContext.close(); 1234&lt;bean id="beanLifeCycle" class="com.znvoid.domain.BeanLifeCycle" init-method="myInit" destroy-method="myDestroy"&gt; &lt;property name="name" value="world"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean class="com.znvoid.utils.MyBeanPostProcess"&gt;&lt;/bean&gt; 属性注入 在 spring 中 bean 的属性注入有两种 构造方法注入123&lt;beann id="" class=""&gt; &lt;constructor-arg index="0" type="java.lang.String" value=""/&gt;&lt;/bean&gt; set方法注入123&lt;bean&gt; &lt;property name="" value=""/&gt;&lt;/bean&gt; SPEL 在 spring3.0 以后的版本提供,格式：#{表达式} 注解开发 &lt;context:annotation-config /&gt;,它代表的是可以使用 spring 的注解&lt;context:component-scan base-package=&quot;包名&quot;&gt;指定spring扫描的包，包含了 &lt;context:annotation-config /&gt; 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- &lt;context:annotation-config /&gt; --&gt; &lt;!-- 下面的配置作用是指定spring扫描的包,它包含了context:annotation-config的功能，所以在开发中一般就不需要在配置上面的 --&gt; &lt;context:component-scan base-package="com.znvoid" /&gt;&lt;/beans&gt; bean注册 使用@Component在类上三个衍生的注解@Rpository 用于 DAO 层@Service 用于 service 层@Controller 用于表现层注意功能相同只是便于阅读 @Component(&quot;user&quot;) public class User {} 属性注解注入 简单属性注解注入 12@Value("tom")private String name; 复杂属性的注解注入 12@Autowiredprivate Iuser user; 注意可以在属性上也可以在set方法上，在属性上时不用提供set方法 其他注解 @Scope 描述bean的作用域 @PostConstruct 自定义的初始化方法 @PreDestory 自定义销毁方法，只对scope为sigleton有效 spring整合Junit4测试 导入jar包 spring-test-xxx.jar 添加注释 @RunWith(SpringJUnit4ClassRunner.class) // spring整合junit4 @ContextConfiguration(locations = “classpath:applicationContext.xml”) // 指spring配置文件位置 public class IOCTest { 使用 @Autowired private User user; @Test public void test2() {system.out.println(user.getUsername); } web开发中的应用 在 web 项目中要使用 spring 需要导入一个 jar 包 spring-web-xxx.jar 在web.xml文件中配置Listener &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;listener&gt; 我们还需要在 web.xml 文件中配置 applicationContext.xml 文件的位置默认情况下会在 WEB-INF 目录 下查找 applicationContext.xmls如果 applicationContext.xml 文件不是在默认位置，我们可以在 web.xml 文件中配置 &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:aplicatinContext.xml&lt;/param-value&gt; &lt;/context-param&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>Sping框架</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring一</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate二]]></title>
    <url>%2FJavaWeb%2FHibernate%E6%A1%86%E6%9E%B6%2FHibernate%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Hibernate主键生成策略 然主键和代理主键 自然主键：具有业务含义 字段 作为主键，比如：学号、身份证号代理主键：不具有业务含义 字段作为主键（例如 自增 id），比如：mysql 自增主键，oracle 序列生成的主键、uuid()方法生成的唯一序列串==建议：企业开发中使用代理主键！== 在 hbm.xml 中可以设置的主键生成策略如下 主键生成器 描述 increment 代理主键。由 hibernate 维护一个变量，每次生成主键时自动以递增。问题：如果有多个应用访问一个数据库，由于每个应用维护自己的主键，所以此时主键可能冲突。建议不采用。 identity 代理主键。由底层数据库生成表识符。条件是数据库支持自动增长数据类型。比如：mysql 的自增主键，oracle 不支持主键自动生成。如果数据库支持自增建议采用 sequence 代理主键。Hibernate 根据底层数据库序列生成标识符。条件是数据库支持序列。比如 oracle 的序列。如果数据库支持序列建议采用。 native 代理主键。根据底层数据库对自动来选择 identity、sequence、hilo由于生成主键策略的控制权由 hibernate 控制，所以不建议采用。 uuid 代理主键。Hibernate 采用 128 位的 UUID 算法来生成标识符。该算法能够在网络环境中生成唯一的字符串标识符。此策略可以保证生成主键的唯一性，并且提供了最好的数据库插入性能和数据库平台的无关性。建议采用。 assigned 自然主键。由 java 程序负责生成标识符。不建议采用。 对象的状态持久化类类三种状态介绍 瞬时态：也叫做临时态或自由态，它一般指我们 new 出来的对象，它不存在 OID,与 hibernate session 无关联，在数据库中也无记录。它使用完成后，会被 jvm 直接回收掉，它只是用于信息携带。简单说：无 OID 与数据库中的信息无关联，不在 session 管理范围内。 持久态：在 hibernate session 管理范围内，它具有持久化标识 OID 它的特点，在事务未提交前一直是持久态，当它发生改变时，hibernate 是可以检测到的。简单说：有 OID 由 session 管理，在数据库中有可能有，也有可有没有。 托管态：也叫做游离态或离线态，它是指持久态对象失去了与 session 的关联，托管态对象它存在 OID,在数据库中有可能存在，也有可能不存在。对于托管态对象，它发生改变时 hibernet 不能检测到。 类三种状态切换 瞬时态(new 出来的) 瞬时——持久 save saveOrUpdate 瞬时—–脱管(游离) 手动设置 oid .持久态 它是由 session 管理 持久——-瞬时 delete() 被删除后持久化对象不在建议使用 持久—–脱管 注意:session 它的缓存就是所说的一级缓存 evict(清除一级缓存 中指定的一个对象) clear(清空一级缓存) close(关闭，清空一级缓存) 脱管态 （它是无法直接获取） 脱管—–瞬时 直接将 oid 删除 脱管—-持久 update saveOrUpdate lock(过时) 一级缓存 Hibernate 的一级缓存就是指 session 缓存 12private transient ActionQueue actionQueue;private transient StatefulPersistenceContext persistenceConteext; actionQueue 它是一个行列队列，它主要记录 crud 操作的相关信息persistenceContext 它是持久化上下文，它其实是真正缓存。 在 session 中定义了一系列的集合来存储数据，它们构成 session 缓存。只要 session 没有关闭，它就会一直存在。 当我们通过 hibernate 中的 session 提供的一些 API 例如 save get update 等进行操作时，就会将持久化对象保存到 session 中，当下一次在去查询缓存中具有的对象(OID 值来判断)，就不会去从数据库查询，而是直接从缓存中获取。Hibernate 的一级缓存存在的目的就是为了减少对数据库访问。 在 hibernate 中还有一个二级缓存，它是 SessionFactory 级别缓存。 演示代码12345678910111213Configuration configure = new Configuration().configure();SessionFactory sessionFactory = configure.buildSessionFactory();Session session = sessionFactory.openSession();session.beginTransaction();//查询到后会将c存储到一级缓存中Customer c = session.get(Customer.class, 1);//会从一级缓存中查询，而不会向数据库发送sqlCustomer cc = session.get(Customer.class, 1);System.out.println(c==cc);session.getTransaction().commit();session.close();sessionFactory.close(); 常用APIclear 清空一级缓存.evict 清空一级缓存中指定的一个对象。refresh 重新查询数据库，用数据库中信息来更新一级缓存与快照 12345678910111213141516171819Configuration configure = new Configuration().configure(); SessionFactory sessionFactory = configure.buildSessionFactory(); Session session = sessionFactory.openSession(); session.beginTransaction(); List&lt;Customer&gt; list =session.createQuery("form Customer"); session.clear();//清空一级缓存 //会先从session一级缓存中获取，如果不存在才会从数据库中获取 Customer c =session.get(Customer.class,1); session.evict(c);//从一级缓存中删除一个指定的对象 Customer cc =session.get(Customer.class,1); cc.setName("kkk") session.refresh(cc);//重新查询数据库，用数据库中的信息更新一级缓存与快照 session.getTransaction().commit(); session.close(); sessionFactory.close(); 持久化对象自动更新数据库 当事务提交，session关闭，向数据库发送请求时，会判断一级缓存中的数据是否与快照区的一致，如果不一致，就会发送sql语句。 123456789101112Configuration configure = new Configuration().configure(); SessionFactory sessionFactory = configure.buildSessionFactory(); Session session = sessionFactory.openSession(); session.beginTransaction(); Customer c = session.get(Customer.class, 1); c.setName("tom");//修改持久化对象修改属性 session.getTransaction().commit(); session.close(); sessionFactory.close(); Hibernate映射关系 Hibernate框架基于ORM设计思想，它将关系型数据库中的表与我们java中的类进行映射，一个对象就对应着表中的一条记录，而表中的字段对应着类中的属性 一对一 唯一外键对应:在任意一方添加外键来描述对应关系 主键对应：一方的主键作为另一方的主键 一对多(多对一) 在多的一方添加外键来描述关联关系 实体类 1234567891011121314151617//订单---多的一方public class Order&#123; private Integer id; private Double total; private String address; //描述订单属于某个客户 private Customer customer; //.....&#125;//客户-----一的一方public class Customer&#123; private Integer id; private String name; //客户可以有多个订单 private Set&lt;Order&gt; orders = new HashSet&lt;&gt;(); //.....&#125; Order.hbm.xml 1&lt;many-to-one name="customer" class="com.xx.domain.Customer" column="customer_id"&gt; Customer.hbm.xml 1234&lt;set name="orders"&gt; &lt;key column="customer_id"/&gt; &lt;one-to-many class="com.xx.domain.Order"&gt;&lt;/set&gt; 测试类 12345678910111213141516171819Customer customer = new Customer();customer.setName("tom");Order o1= new Order();Order o2= new Order();o1.setTotal(100d);o2.setTotal(200d);o1.setAddress("北京");o2.setAddress("上海");o1.setCustomer(customer);o2.setCustomer(customer);customer.getOrders().add(o1);customer.getOrders().add(o2);session.save(customer);session.save(o1);session.save(o2); 多对多 通过一张中间表来描述其对应关系 级联 保存订单时保存客户，需要在订单的hbm配置文件中修改设置cascade=save-update 那么在保存订单时就可以自动将客户保存 双向关联维护123inverse属性来设置，双向关联时由哪一方来维护表与表之间的关系&lt;set name="orders" inverse="true"&gt;... nverse它的值如果为true代表，由对方来维护外键。Inverse它的值如果为false代表，由本方来维护外键。关于inverse的取值: 外键在哪一个表中，我们就让哪一方来维护外键。]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>Hibernate框架</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate一]]></title>
    <url>%2FJavaWeb%2FHibernate%E6%A1%86%E6%9E%B6%2FHibernate%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Hibernate ORM框架，对jdbc的封装完成对数据库的操作 知识点 基本配置 常用AP 关联映射 检索方式 优化方式 优点 Hibernate对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码 Hibernate是一个基于jdbc的主流持久化框架，是一个优秀的orm实现，它很大程度的简化了dao层编码工作 Hibernate是企业级开发中主流框架。映射的灵活性很出色。它支持很多关系型数据库 快速入门 下载hibernate的jar包 导入相关的jar包 数据库连接的jar包 日志jar包及日志配置文件 配置映射配置文件 用于描述实体类与数据表之间的映射关系。位置:要与实体类在同一个包下名称:类名.hbm.xml约束:hibernate 核心 jar 包下的 org.hibernate 包下 hibernate-mapping-3.0.dtd 文件中查找 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;!-- packgae 包名--&gt;&lt;hibernate-mapping package="com.xx.domain"&gt; &lt;!-- 当 packgae未设置时name属性它是实体类的全名 table 表的名称 catalog 数据库名称 --&gt; &lt;class name="Customer" table="t_customer" catalog="hibernateTest"&gt; &lt;!-- id它是用于描述主键 --&gt; &lt;id name="id" column="c_id" type="int"&gt; &lt;!-- java数据类型 --&gt; &lt;!-- 主键生成策略 --&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- 使用property来描述属性与字段的对应关系 --&gt; &lt;property name="name" column="c_name" length="20" type="string"&gt;&lt;/property&gt; &lt;!-- hibernate数据类型 --&gt; &lt;property name="address"&gt; &lt;column name="c_address" length="50" sql-type="varchar(50)"&gt;&lt;/column&gt; &lt;!-- sql数据类型 --&gt; &lt;/property&gt; &lt;!-- 配置关系属性：一个客户关联多个订单 --&gt; &lt;set name="orders" inverse="true"&gt; &lt;key column="c_customer_id" /&gt;&lt;!-- 指定查询order的外键，与 --&gt; &lt;one-to-many class="com.xxx.domain.Order" /&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 核心配置文件 包含了连接数据库相关信息，hibernate 相关配置等。位置:在 src 下创建一个 hibernate.cfg.xml约束:hiberante 核心 jar 包下的 org.hibernate 包下 hibernate-configuration-3.0.dtd 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 配置关于数据库连接的四个项 driverClass url username password --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///hibernateTest&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;&lt;/property&gt; &lt;!-- 设置连接提供者 --&gt; &lt;property name="hibernate.connection.provider_class"&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt; &lt;!-- c3p0连接池的配置 --&gt; &lt;property name="hibernate.c3p0.max_size"&gt;20&lt;/property&gt; &lt;!-- 最大连接池 --&gt; &lt;property name="hibernate.c3p0.min_size"&gt;5&lt;/property&gt; &lt;!-- 最小连接数 --&gt; &lt;property name="hibernate.c3p0.timeout"&gt;120&lt;/property&gt; &lt;!-- 超时 --&gt; &lt;property name="hibernate.c3p0.idle_test_period"&gt;3000&lt;/property&gt; &lt;!-- 空闲连接 --&gt; &lt;!-- 用于设置事务提交方式 --&gt; &lt;property name="hibernate.connection.autocommit"&gt;false&lt;/property&gt; &lt;!-- 可以将向数据库发送的sql显示出来 --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 格式化sql --&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- hibernate的方言 --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 自动创建表 --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 配置hibernate的映射文件所在位置 --&gt; &lt;mapping resource="com/xxx/domain/Customer.hbm.xml" /&gt; &lt;mapping resource="com/xxx/domain/Order.hbm.xml" /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 代码测试12345678910111213141516171819202122232425262728//pojo 类public class Customer&#123; private Integer id; private String name; private String address; //....&#125;//测试类public Demo&#123; @Test public void test()&#123; Configuration configure = new Configuration().configure(); SessionFactory sessionFactory = configure.buildSessionFactory(); Session session = sessionFactory.openSession(); //开启事务 session.beginTransaction(); //业务操作 Customer c = new Customer(); c.setName("tom"); c.setAddress("北京"); session.save(c); //提交 session.getTransaction().commit(); session.close(); sessionFactory.close(); &#125;&#125; 工作原理及步骤 加载 hibernate 的配置文件，读取配置文件的参数(jdbc 连接参数，数据 库方言，hbm 表与对象关系映射文件) 创建 SessionFactory 会话工厂(内部有连接池) 打开 session 获取连接，构造 session 对象(一次会话维持一个数据连接， 也是一级缓存) 开启事务 进行操作 提交事务 关闭 session(会话)将连接释放 关闭连接池 配置详解核心配置文件配置 对于hibernate的核心配置文件有两种方式 1. hibernate.cfg.xml 2. hibernate.properties 开发中使用比较多的是 hibernate.cfg.xml 这种方式，原因它的配置能力更强，易于修改 加载数据库相关的信息（必要的） 12345678&lt;!--数据库驱动--&gt;&lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;&lt;!--url--&gt;&lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///hibernateTest&lt;/property&gt;&lt;!--用户名--&gt;&lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt;&lt;!--密码--&gt;&lt;property name="hibernate.connection.password"&gt;&lt;/property&gt; hibernate 相关配置 12345678910111213141516&lt;!-- 用于设置事务提交方式 --&gt;&lt;property name="hibernate.connection.autocommit"&gt;false&lt;/property&gt;&lt;!-- 可以将向数据库发送的sql显示出来 --&gt;&lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt;&lt;!-- 格式化sql --&gt;&lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt;&lt;!--必要的 hibernate的方言,指定连接的数据库是MySQL或是Oracle等 --&gt;&lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;&lt;!-- 自动创建表Create-drop 每次都会创建一个新的表，执行完成后删除。一般在测试中使用Create 每次都会创建一个新的表,一般是在测试中使用update 如果数据库中有表，不创建，没有表创建，如果映射不匹配，会自动更新表结构(只能添加)validate 只会使用存在的表，并且会对映射关系进行校验 --&gt;&lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; 加载映射配置文件（必要） 123&lt;!-- 配置hibernate的映射文件所在位置 --&gt; &lt;mapping resource="com/xxx/domain/Customer.hbm.xml" /&gt;&lt;mapping resource="com/xxx/domain/Order.hbm.xml" /&gt; 连接池 12345678&lt;!-- 设置连接提供者 --&gt;&lt;property name="hibernate.connection.provider_class"&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt;&lt;!-- c3p0连接池的配置 --&gt;&lt;property name="hibernate.c3p0.max_size"&gt;20&lt;/property&gt; &lt;!-- 最大连接池 --&gt;&lt;property name="hibernate.c3p0.min_size"&gt;5&lt;/property&gt; &lt;!-- 最小连接数 --&gt;&lt;property name="hibernate.c3p0.timeout"&gt;120&lt;/property&gt; &lt;!-- 超时 --&gt;&lt;property name="hibernate.c3p0.idle_test_period"&gt;3000&lt;/property&gt; &lt;!-- 空闲连接 --&gt;` 映射文件配置 映射配置文件它的名称是类名.hbm.xml，它一般放置在实体类所在的包下 统一声明包名，这样在&lt;clss&gt;中就不需要写累的全名了 &lt;hibernate-mapping package=&quot;com.itheima.domain&quot;&gt; 关于&lt;class&gt;标签的配置 name 属性:类的全名称 table 表的名称,可以省略，这时表的名称就与类名一致 catalog 属性:数据库名称 可以省略.如果省略，参考核心配置文件中 url 路径中的库 名称 关于&lt;id&gt;标签 首先它必须存在。&lt;id&gt;是用于建立类中的属性与表中的主键映射。 name 类中的属性名称 column 表中的主键名称 column 它也可以省略，这时列名就与类中属性名称一致 length 字段长度 type 属性 指定类型 &lt;generator&gt;它主要是描述主键生成策略. 关于&lt;property&gt;标签 它是描述类中属性与表中非主键的映射关系 Hibernate 常用 APIConfiguration 加载 hibernate 配置 123456// 主要加载 src 下的 hibernate.cfg.xmlConfiguration config=new Configuration().config();//主要加载的 src 下的 hibernate.propertiesConfiguration config=new Configuration();//加载指定的名称的配置文件Configuration config=new Configuration().config(核心配置文件名称); sessionFactory 接口，负责初始化 Hibernate。它充当数据存储源的代理，并负责创建 Session对象 12//通过 Configuration 得到SessionFactorySessionFactory sessionFactory = configure.buildSessionFactory(); 注意的是 SessionFactory 并不是轻量级的，因为一般情况下，一个项目通常只需要一个 SessionFactory 就够，当需要操作多个数据库时，可以为每个数据库指定一个 SessionFactory Session 责执行被持久化对象的 CRUD 操作,Session 对象是非线程安全的 获取 SessionFactory.openSession() ; 相当于直接通过 SessionFactory 创建一个新的 Session,使 用完成后要手动调用 close 来关闭。 SessionFactory.getCurrentSession(); 获取一个与线程绑定的 Session,当我们提交或事务回 滚后会自动关闭。 常用的方法: save 保存对象 update 修改操作 delete 删除 get/load 根据 id 进行查询 savenOrUpdate 执行 save 或 update 操作 createQuery()获取一个 Query 对象 CreateSQLQUery()获取一个可以操作 sql 的 SQLQuery 对象 createCriteria() 获取一个 Criteria 它可以完成条件查询 示例 12345678910//获取sessionSession session = sessionFactory.openSession();//开启事务session.beginTransaction();//CRDUsession.save(c);//事务提交session.getTransaction().commit();//关闭session.close(); Transaction 管理事务，它是 hibernate 的事务接口，对底层的事务进行了封装 获取 session.beginTransaction(); 事务操作commit 事务提交 rollback 事务回滚 默认情况下事务是不会自动提交的,可在在核心配置文件中开启配置 12&lt;!-- 用于设置事务提交方式 --&gt;&lt;property name="hibernate.connection.autocommit"&gt;true&lt;/property&gt; Query Query 接口让你方便地对数据库及持久对象进行查询，它可以有两种表达方式：HQL 语言或本地数据库的 SQL 语句 HQL查询所有操作1234Query query = session.createQuery("from Customer");//from后面是类名List list = query.list();System.out.println(list); 分页查询12345678Query query = session.createQuery("from Customer");//设置起始的查询位置query.setFirstResult(10);//设置一页的数量query.setMaxResults(10);//上面的两句相当于limit 10,10List list = query.list();System.out.println(list); 查询指定列信息123456// Query query = session.createQuery("select name,address from Customer"); //这时我们得到的不在是Customer对象，而是Object[]// List&lt;Object[]&gt; list = query.list();Query query = session.createQuery("select new Customer(name,address) from Customer");List&lt;Customer&gt; list = query.list();// 我们可不可以得到List&lt;Customer&gt;,我们要想得到这个结果，可以使用hibernate中投影查询。我们只需要在Customer类中提供name与address做为参数的构造方法System.out.println(list); 条件查询 可以使用 where 关键字 12345678910111213141516// 查询name=姓名0的信息// Query query = session.createQuery("from Customer where name=?");// //无名称参数// 要对参数进行赋值// query.setParameter(0, "姓名0");Query query = session.createQuery("from Customer where name=:myname"); // 有名称参数// 对有名称参数进行赋值query.setParameter("myname", "姓名0");// List&lt;Customer&gt; list = query.list();// System.out.println(list);// 如果能保证结果就是唯一的，那么可以使用Customer c = (Customer) query.uniqueResult();System.out.println(c); SQLQuery要想执行本地 sqlSQLQuery sqlQuery=session.createSqlQuery(String sql);使用 addEntity 方法来将结果封装到指定的对象中，如果不封装，得到的是 List如果 sql 中有参数，我们使用 setParameter 方法完成参数传递。如果结果就是一个可以使用 uniqueResult()来得到一个单独对象。 123456789// 执行select * from t_customer;SQLQuery sqlQuery = session.createSQLQuery("select * from t_customer");// List&lt;Object[]&gt; list = sqlQuery.list();// System.out.println(list);// 想要将结果封装到Customer对象中sqlQuery.addEntity(Customer.class);List&lt;Customer&gt; list = sqlQuery.list();System.out.println(list); Criteria Criteria 接口与 Query 接口非常类似，允许创建并执行面向对象的标准化查询。值得注意的是 Criteria 接口也是轻量级的，它不能在 Session 之外使用 1234567891011121314151617181920212223// 得到CriteriaCriteria criteria = session.createCriteria(Customer.class);// 查询所有// List&lt;Customer&gt; list = criteria.list();// System.out.println(list);// 分页查询// criteria.setFirstResult(firstResult)// criteria.setMaxResults(maxResults)// 多条件查询// 1.查询name='姓名1'//criteria.add(Restrictions.eq("name", "姓名1")); // where name='姓名1';// 2.查询address='上海'//criteria.add(Restrictions.eq("address", "上海"));//Customer c = (Customer) criteria.uniqueResult();//System.out.println(c);//查询name='姓名1' 或者 address='上海'criteria.add(Restrictions.or(Restrictions.eq("name", "姓名1"),Restrictions.eq("address","上海")));List&lt;Customer&gt; list = criteria.list();System.out.println(list);]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>Hibernate框架</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2三]]></title>
    <url>%2FJavaWeb%2FStruts%E6%A1%86%E6%9E%B6%2FStruts2%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Struts2三知识点 struts2文件上传 struts2AJax开发 注解开发 文件上传 struts2框架支持文件上传,使用一个fileUpload的interceptor来完成 使用步骤 文件上传的jsp页面 form表单提交方式为post 有input标签type属性值为file form表单有enctype=’multipart/form-data’1234&lt;form action="$&#123;pageContext.request.contextPath&#125;/fileUpload" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="upload"&gt; &lt;input type="submit" value="上传"&gt;&lt;/form&gt; 创建action类 12345678910111213141516171819public class UploadAction &#123; //要与页面type='file'的input标签的name属性值一致 private File upload; private String uploadContentType; // 上传文件的mimeType类型 private String uploadFileName; // 上传文件的名称 //...set /get 方法 public void uploadFile() &#123; String path = ServletActionContext.getServletContext().getRealPath("/upload"); // 得到upload目录在tomcat的绝对磁盘路径 // 创建一个服务器端文件 File dest = new File(path, uploadFileName); try &#123; // 完成文件上传操作 FileUtils.copyFile(upload, dest); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意事项 文件大小控制 在default.properties中 struts.multipart.maxSize=2097152 (2m)。它是描述文件上传时允许的最大值，只需要在struts.xml文件中 &lt;constant name =&#39;struts.multipart.maxSize&#39; value=&quot;20971520&quot;&gt; 针对某一个action上传的文件大小限制,类型限制，在action中配置拦截器 12345678&lt;action ...&gt; &lt;interceptor-ref name="fileUpload"&gt; &lt;!-- &lt;param name="maximumSize"&gt;&lt;/param&gt; --&gt; &lt;!-- 设置每一个action允许的上传文件大小 --&gt; &lt;!-- &lt;param name="allowedTypes"&gt;&lt;/param&gt; --&gt; &lt;!-- 设置上传允许的文件的mimeType类型，多个使用逗号分开 --&gt; &lt;param name="allowedExtensions"&gt;bmp,txt&lt;/param&gt; &lt;!-- 设置上传文件允许的后缀名，多个使用逗号分开 --&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="defaultStack"/&gt;&lt;/action&gt; 多文件上传，在action类中使用数组或list成员属性 AJax开发用HttpServletResponse响应数据 在struts2框架中可以获取HttpServletResponse对象，就可以通过response来完成将数据(json)响应到浏览器过程 struts2框架的json插件 将我们自己配置文件中的&lt;package extends=”json-default”&gt; Action的返回视图&lt;result name=”” type=”json”&gt; 因为我们配置了上面两步，那么struts2框架就会将valueStack中的栈顶元素转换成json响应到浏览器 注解开发 需要导入struts2-convention-plugin-2.3.24.jar 123456789101112@Namespace("/") // 相当于 &lt;package namespace="/"&gt;@ParentPackage("struts-default") // &lt;package extends="struts-default"&gt;public class HelloAction &#123; // &lt;action name="hello" class="" method=""&gt; //&lt;result name="" type=""&gt;/success.jsp&lt;/result&gt; @Action(value="hello",results=&#123;@Result(name="success",location="/success.jsp")&#125;) public String sayHello() &#123; return "success"; &#125;&#125; 注意点们在action类中定义了注解，strtus2框架怎样识别它们?原因:我们必须查看插件包中的配置 &lt;constant name=&quot;struts.convention.package.loctor&quot; value=&quot;action,actions,struts,struts2&quot;&gt;是在action,actions,struts,struts2这样的包下扫描注解]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>Struts框架</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2二]]></title>
    <url>%2FJavaWeb%2FStruts%E6%A1%86%E6%9E%B6%2FStruts2%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Struts2知识学习二目录 servlet API ognl valueStack Inteceptor 获取Servlet API 在Struts2 中如何获取Servlet的API? ServletActionContext获取1234HttpServletRequest request = ServletActionContext.getRequest();HttpServletResponse response = ServletActionContext.getResponse();ServletContext servletContext =ServletActionContext.getServletContext(); 采用注入方式-action类实现接口Struts2框架在运行时，请求会被StrutsPrepareAndExecuteFilter拦截，会根据请求，去strtus.xml文件中查找到匹配的action，在action执行前，会走一些interceptor 默认执行的拦截器是struts-default.xml文件中定义的。在默认执行的拦截器中有一个 &lt;interceptor-ref name=&quot;servletConfig&quot;&gt; &lt;interceptor name=&quot;servletConfig&quot; class=&quot;org.apche.struts2.interceptor.ServletConfigInterceptor&quot;&gt; 通过看源码可知：ServletRequestAware, 实现这个接口可以获取HttpServletRequestServletResponseAware ,实现这个接口可以获取HttpServletResponseServletContextAware实现这个接口可以获取ServletContext… 12345678910111213141516171819202122public class LoginAction extends ActionSupport implements ServletRequestAware, ServletResponseAware, ServletContextAware&#123; private HttpServletRequest request; private HttpServletResponse response; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125; @Override public void setServletResponse(HttpServletResponse response) &#123; this.response = response; &#125; @Override public void setServletContext(ServletContext arg0) &#123; &#125;&#125; ognl表达式 Object-Graph Navigation Language(对象图导航语言) 三要素 表达式Ognl Context上下文 Root 根 在struts2框架中，OGNLContext的实现者为ActionContext(Stack Context)，而 OGNLContext中的Root Object是Value Stack，并且 Application、Session、Request等我们经常访问的对象(Map表示)都被放到了ActionContext中 支持对象的操作12345678910// String s="hello";// int length = s.length();// 1.获取上下文对象OgnlContextOgnlContext context = new OgnlContext(); // 它就是一个java.util.Map// 2.操作Object root = context.getRoot();Object value = Ognl.getValue("'hello'.length()", context, root);System.out.println(value); 支持静态成员访问123OgnlContext context = new OgnlContext();Object value = Ognl.getValue("@java.lang.Math@random()", context, context.getRoot());Object value2 = Ognl.getValue("@java.lang.Math@PI", context, context.getRoot()); ognl上下文 如果从根中获取数据，不需要添加#号，如果不是从根中获取，需要# 12345678910111213141516171819OgnlContext context = new OgnlContext(); // 它就是一个java.util.Map// 向上下文中存储数据context.put("username", "tom");// 操作Object value = Ognl.getValue("#username", context, context.getRoot());System.out.println(value);// 存储Map数据Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();map.put("username", "fox");// 将map存储到context的根中context.setRoot(map);// 操作Object value = Ognl.getValue("username", context, context.getRoot()); 操作集合1234Object value = Ognl.getValue("&#123;'hello','ognl','word'&#125;", context,context.getRoot()); //相录于创建了一个List集合//Object value = Ognl.getValue("#&#123;'username':'tom','password':'123'&#125;", context,context.getRoot()); //相录于创建了一个Map集合context.setRoot(value);System.out.println(Ognl.getValue("[0]",context, context.getRoot())); Struts2框架中如何使用ognlvalueStack 将action中产生的数据携带到页面上,它是个容器 一个valueStack对应一个action，valueStack贯穿整个action的生命周期。rquest——-&gt;Action——&gt;ValueStackstruts2框架将valueStack保存在request中。 valueStack内部结构 主要由两部分组成 CompoundRoot:它就是一个ArrayList它主要存储的是action的相关数据，ognl不加# Map&lt;String,Object&gt; context:就是一个MapContext中主要存储了一些引用，这个引用主要是关于web开发中相关信息，ognl加# 获取valueStack 直接从request域中获取 12HttpServletRequest request = ServletActionContext.getRequest();ValueStack stack = (ValueStack)request.getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY); 通过ActionContext对象获取 ValueStack stack = ActionContext.getContext().getValueStack(); ActionContext action上下文，strtus2框架它使用actionContext来保存Action在执行过程中所需要的一些对象，例如 session, application… ActionContext的获取是通过它的静态方法getContext()得到。Struts2会根据每一次的http请求来创建对应的ActionContext,它是与当前线程绑定的。每一次请求，就是一个线程，对应着一个request,每一次请求，会创建一个Action,每一个action对应一个ActionContext.每一次请求也对应着一个valueStack.request—ActionContext—-Action—–ValueStaci它们都对应着一次请求(一个线程).valueStack与ActionContext本质上是可以获取 valueStack操作 valueStack来存储数据时，主要是向root中存储 手动存储1234567stack.put("hello");//向root中存储stack.set("name","value");//底层会创建一个HashMap，保存数据，在将hashMap存储到root中/*user =new User();user.setUsername("tom");user.setPassword("123")*/ 自动存储 每次请求，访问action，这个对象会存储到valueStack中如果action实现了ModeDriver接口 会将mode对象存入valueStack中 获取数据12345678&lt;%@taglib prefix="s" uri="/struts-tags"%&gt; &lt;!--手动存储后的取值示例--&gt; &lt;s:property value="name"&gt; &lt;s:property value="[1].top"&gt; &lt;s:property value="model.username"&gt; &lt;!-- $&#123;name&#125; $&#123;model.username&#125;--&gt; EL表达式能获取是因为Struts2框架对request进行了增强，重写了getAttribute方法，如果在request域中查找不到数据，就会在valueStack中获取。 Intercepter Struts2中的interceptor它是基于spring aop思想，而aop思想它本质上是通过动态代理来实现。strtus2的拦截器它主要是拦截Action的操作，在action的执行前或执行后进行一些其它的功能操作 执行的过程 当我们发送请求访问Action时，会被StrutsPrepareAndExecuteFilter拦截在其doFilter方法内执行了 execute.executeAction(request, response, mapping);这个代码执行后dispatcher.serviceAction(request, response, mapping); serviceAction方法执行在这个方法执行过程中会创建Action代理对象ActionProxy proxy = getContainer().getInstance(ActionProxyFactory.class).createActionProxy(namespace, name, method, extraContext, true, false);通过proxy去执行了proxy.execute(); 在execute方法内return invocation.invoke();invocation它是ActionInvocation一个对象 在invoke方法内会去加载我们的配置文件，将配置文件中所有的interceptor得到进行遍历 12345678910111213if (interceptors.hasNext()) &#123; final InterceptorMapping interceptor = interceptors.next(); String interceptorMsg = "interceptor: " + interceptor.getName(); UtilTimerStack.push(interceptorMsg); try &#123; resultCode = interceptor.getInterceptor().intercept(DefaultActionInvocation.this); &#125; finally &#123; UtilTimerStack.pop(interceptorMsg); &#125;&#125; else &#123; resultCode = invokeActionOnly();&#125; 在每一个拦截器的interceptor方法内，又调用了DefaultActionInvocation的invoke方法，其实就是递归调用 自定义Intercepter 创建一个类实现Intercept接口 在Struts.xml配置文件中配置intercept 12345678&lt;interceptors&gt;&lt;interceptor name="myInterceptor" class="MyInterceptor"&gt; &lt;/interceptor&gt; &lt;interceptor-stack name="myStack"&gt; &lt;interceptor-ref name="myInterceptor"/&gt; &lt;interceptor-ref name="defaultStack"/&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt; 在action中引入intercept 1234&lt;action ...&gt; ... &lt;interceptor-ref name="myStack"/&gt;&lt;/action&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>Struts框架</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2一]]></title>
    <url>%2FJavaWeb%2FStruts%E6%A1%86%E6%9E%B6%2FStruts2%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Struts2一框架的概述 用于解决或处理复杂的问题。 优点：减少开发成本，缩短开发周期，有一定的标准，后期维护方便 常用的框架 SSH struts2 spring hibernate SSM springmvc spring mybatis 服务器的三层结构 web层 跟页面交互 service层 处理业务逻辑 Dao层 数据库交互 Struts框架 基于MVC设计模式的web应用框架，作为控制器来建立模型与视图的数据交互Struts2=struts1 + webwork 核心 拦截器 action ognl表达式 与valueStack 简单入门使用步骤 导入相关的jar文件 在web.xml中配置一个Filter struts.xml配置 创建action类完成逻辑 相关的jar包 13个jar包 Filter配置 在web.xml文件中配置StrutsPrepareAndExecuteFilter 1234567891011121314151617&lt;filter&gt; &lt;filter-name&gt;struts2Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter &lt;/filter-class&gt; &lt;!-- 可以声明struts2框架常量值，不推荐 &lt;init-param&gt; &lt;param-name&gt;struts.i18n.encoding&lt;/param-name&gt; &lt;param-value&gt;GBK&lt;/param-value&gt; &lt;/init-param&gt; --&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; struts.xml文件 scr目录下,文件名是struts.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;!-- 声明常量 --&gt; &lt;constant name="struts.i18n.encoding" value="UTF-8"&gt;&lt;/constant&gt; &lt;!-- 可以帮助我们解决post请求乱码问题 --&gt; &lt;!-- &lt;constant name="struts.action.extension" value="action"&gt;&lt;/constant&gt; --&gt;&lt;!-- 指定访问strtsu2框架路径的扩展名 --&gt; &lt;constant name="struts.devMode" value="true"&gt;&lt;/constant&gt; &lt;!-- 配置这项后，它会提供更加详细报错信息，以及在struts.xml文件修改后不在需要重启服务器 --&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="true"&gt;&lt;/constant&gt;&lt;!-- 开启动态方法调用，调用action标签中为申明的方法，访问路径用!+方法名 --&gt; &lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;!--全局result--&gt; &lt;global-results&gt; &lt;result name="" type=""&gt;&lt;/result&gt; &lt;/global-results&gt; &lt;action name="url路径" clss="action类的全类名" method="要执行action类中的方法名"&gt; &lt;result name="方法的返回值1" type="跳转的类型（重定向redirect或转发dispatcher）"&gt;跳转的路径&lt;/result&gt; &lt;result name="方法的返回值2"&gt;跳转的路径&lt;/result&gt; &lt;/actin&gt; &lt;!--具体示例 --&gt; &lt;!--&lt;action name="login" class="web.action.LoginAction" method="login"&gt; &lt;result name="success" type="redirect"&gt;/success.jsp&lt;/result&gt; &lt;result name="fail"&gt;/fail.jsp&lt;/result&gt; &lt;/action&gt;--&gt; &lt;!-- &lt;action name="bookadd" class="web.action.BookAction" method="addBook"&gt;&lt;/action&gt; &lt;action name="bookupdate" class="web.action.BookAction" method="updateBook"&gt;&lt;/action&gt; &lt;action name="bookdel" class="web.action.BookAction" method="delBook"&gt;&lt;/action&gt; &lt;action name="bookfind" class="web.action.BookAction" method="findBook"&gt;&lt;/action&gt; --&gt; &lt;!-- action类继承ActionSupport，以上操作可以简化，使用*通配置来操作 --&gt; &lt;!-- &lt;action name="*_*" class="web.action.&#123;1&#125;Action" method="&#123;2&#125;"&gt;&lt;/action&gt; --&gt; &lt;/package&gt;&lt;/struts&gt; package标签 name 属性 定义包名，必须唯一namespace 属性 和action标签的name属性联合使用来确定一个action的访问路径extens 属性 指定继承那个包，一般值是struts-defaultAbstuct属性 代表当前包是个抽象的 action标签 name 属性 与package标签的namespace属性联合使用来确定action的访问路径class 属性 action类的全类名method属性 指示当前的action类中的哪个方法执行 result标签 指示结果视图name属性 与action类method方法的返回值对应type属性 指定跳转方式，默认dispatcher 关于action配置中的class与method的默认值以及result中的name的默认值1234&lt;!--可以这样配置，--&gt;&lt;action name="test"&gt; &lt;result&gt;/success.jsp&lt;/result&gt;&lt;/action&gt; 在strtus-default.xml文件中配置&lt;default-clss-ref class=&quot;com.opensymphony.xwork2.ActionSupport&quot;/&gt;查找不到指定的class及对应的method就会执行ActionSupport类中的execute方法。在这个类的execute方法中默认返回的是”success”。也就是说，result的name属性默认值是success,默认的跳转方式是请求转发 dispatcher Action类 三种方式 pojo类普通的java类 ，已在Struts.xml文件中配置，无耦合但所有功能都有自己完成获取请求参数 在类中设置成员变量(名字与请求参数名一致),提供set和get方法 12345678910111213141516171819202122232425262728public class LoginAction&#123; //根据struts.xml文件中的配置，路径url为package标签的namespace+对应的action标签的name。当请求URL路径为/login 执行 private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String login()&#123; //业务逻辑处理 if(/*处理结果*/)&#123; return "success" &#125;else&#123; return "fail"; &#125; &#125;&#125; 创建一个类实现Action接口 Action接口定义了五个常量和一个execute方法 ERROR : 错误视图INPUT: 它是struts2框架中interceptor中发现问题后会访问的一个视图LOGIN:它是一个登录视图，可以在权限操作中使用NONE:它代表的是null,什么都不做（也不会做跳转操作）SUCCESS:这是一个成功视图 创建一个类继承ActionSupport类 ActionSupport类也实现了Action接口具有丰富的功能，如表单校验。。但耦合度高 执行流程 核心拦截器 struts.xml 匹配action 执行action类的方法中的业务逻辑 根据Action中方法的执行结果来选择来跳转页面Resutl视图 配置文件加载顺序 default.properties 文件，声明了框架的常量 一批配置文件 struts-default.xml 声明 intercept result bean struts_plugin.xml 插件的配置声明 struts.xml 工程使用框架的配置 自定义的struts.properties 定制常量 自定义配置提供 加载web.xml配置文件，框架在web.xml文件的相关配置 bean的相关配置 常量配置 在scr下的创建一个struts.properties文件 在web.xml配置 在struts.xml声明 推荐 &lt;!-- 声明常量 --&gt; &lt;constant name=&quot;struts.i18n.encoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/constant&gt; 数据的封装 两种方式 属性驱动 直接在action类中提供与请求参数匹配属性，提供get/set方法 在action类中创始一个javaBean,对其提供get/set ，在请求时页面上要进行修改，例如user.usernameuser.password ,要使用ognl表达式 username:&lt;input type=&quot;text&quot; name=&quot;user.username&quot;&gt;&lt;br&gt; password:&lt;input type=&quot;password&quot; name=&quot;user.password&quot;&gt;&lt;br&gt; 以上两种方式的优缺点:第一种比较简单，在实际操作我们需要将action的属性在赋值给模型(javaBean)去操作第二种:不需要在直接将值给javaBean过程，因为直接将数据封装到了javaBean中。它要求在页面上必须使用ognl表达式，就存在页面不通用问题。 模型驱动 1.让Action类要实现一个指定接口ModelDriven 2.实例化模型对象(就是要new出来javaBean) 3.重写getModel方法将实例化的模型返回。 12345678910111213public class LoginAction implements ModelDriven&lt;User&gt; &#123; private User user = new User(); @Override public User getModel() &#123; return user; &#125; // 登录操作 public String login() &#123; //登录逻辑 &#125;]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>Struts框架</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb Servlet过滤器Filter]]></title>
    <url>%2FJavaWeb%2FJavaWeb-Filter%2F</url>
    <content type="text"><![CDATA[JavaWeb Servlet过滤器Filter什么是过滤器 Filter 可以过滤客户端向服务器发送的请求 编写一个类实现Filter接口 web.xml 配置过滤器 123456789&lt;!-- 配置过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;aaa&lt;/filter-name&gt; &lt;filter-class&gt;filter类的全名&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;aaa&lt;/filter-name&gt; &lt;url-pattern&gt;拦截的路径&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器生命周期 创建：服务器启动时 web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作，filter对象只会创建一次，init方法也只会执行一次。通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。 销毁：服务器关闭时 Web容器调用destroy方法销毁Filter。destroy方法在Filter的生命周期中仅执行一次。在destroy方法中，可以释放过滤器使用的资源。 FilterConfig类在过滤器初始化时传入 12345678910111213141516public void init(FilterConfig filterConfig) throws ServletException &#123; // 获得当前的Filter的名称: String filterName = filterConfig.getFilterName(); System.out.println(filterName); // 获得初始化参数: String username = filterConfig.getInitParameter("username"); String password = filterConfig.getInitParameter("password"); System.out.println(username+" "+password); // 获得所有的初始化参数的名称: Enumeration&lt;String&gt; en = filterConfig.getInitParameterNames(); while(en.hasMoreElements())&#123; String name = en.nextElement(); String value = filterConfig.getInitParameter(name); System.out.println(name+" "+value); &#125;&#125; 问题：配置Servlet服务器启动初始化，filter与Servlet的初始化顺序Listener &gt; Filter &gt; Servlet，Listener的初始化最早，Filter次之。他俩的初始化都是在容器启动完成之前初始化的。Servlet没有初始化，原因是没有匹配的请求进来。如果想要servlet自动初始化，需要在指定的servlet中配置&lt;load-on-startup&gt;参数，没有此标签，默认启动时servlet不进行初始化。 初始化的顺序跟Listener、Filter、Servlet在web.xml中的顺序无关，而多个Filter或多个Servlet的时候，谁的mapping在前面，谁先初始化。当请求资源匹配多个 filter-mapping 时，filter 拦截资源是按照 filter-mapping 配置节出现的顺序来依次调用 doFilter() 方法的。 如果web.xml中配置了&lt;context-param&gt;，初始化顺序：context-param &gt; Listener &gt; Filter &gt; Servlet FilterChain 过滤器链 过滤器链中的过滤器的执行的顺序与&lt;filter-mapping&gt;的配置顺序有关. 在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter，当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。 过滤器的相关配置 配置 完全路径匹配 以/开头 /demo.jsp 目录匹配 以/开头以*结束 扩展名匹配 不能以/开头，以开始 如：.jsp 配置 REQUEST :默认值 &nbsp;&nbsp;&nbsp;&nbsp;如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。 FORWARD ：转发 &nbsp;&nbsp;&nbsp;&nbsp;如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用 INCLUDE ：包含 &nbsp;&nbsp;&nbsp;&nbsp;如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。 ERROR ：错误 &nbsp;&nbsp;&nbsp;&nbsp; 如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用 自动登录分析登录时的分析： 登录成功后利用Cookie记住用户名和密码 用户名和密码拼接 过滤器的分析： 判断session中是否有用户的信息: session中如果有:放行. session中没有: 从Cookie中获取: Cookie中没有:放行. Cookie中有: 获取Cookie中存的用户名和密码到数据库查询. 没有查询到:放行. 查询到:将用户信息存入到session . 放行. 代码 登录部分代码 123456789101112//登录成功 //自动登录 if ("true".equals(request.getParameter("autologin"))) &#123;//自动登录选择框被选择 Encrypt encrypt = new Encrypt();//字符串编码工具类 String autologin = encrypt.encrypt(account) + "-" + encrypt.encrypt(password); Cookie cookie = new Cookie("autologin", autologin); cookie.setPath(request.getContextPath()); cookie.setMaxAge(60 * 60 * 24 * 7); response.addCookie(cookie); &#125; request.getSession().setAttribute("user", existUser); 过滤器代码 123456789101112131415161718192021222324252627282930 HttpServletRequest req =(HttpServletRequest) request; HttpSession session = req.getSession(); User user =(User) session.getAttribute("user"); if(user==null) &#123;//判断是否已经登录成功 Cookie[] cookies = req.getCookies(); Cookie cookie = CookieUtil.findCookie(cookies, "autologin"); if(cookie!=null) &#123;//从cookie中获取保存的账户和密码 String str =cookie.getValue(); boolean mFlag = str.matches("([A-Z]+)-([A-Z]+)"); if(mFlag) &#123; String[] strs = str.split("-"); Encrypt encrypt = new Encrypt(); try &#123;//解码出账户和密码 String username = encrypt.dencrypt(strs[0]); String password = encrypt.dencrypt(strs[1]); user = new User(); user.setUsername(username); user.setPassword(password); //从数据库匹配用户名和密码 User existUser = new UserServiceImpl().login(user); if(existUser!=null) &#123; session.setAttribute("user", existUser); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;chain.doFilter(req, response); 通用网站的字符集编码过滤器：代码实现1234567891011121314151617181920212223242526272829public class MyHttpServletRequestWrapper extends HttpServletRequestWrapper&#123; private HttpServletRequest request; public MyHttpServletRequestWrapper(HttpServletRequest request) &#123; super(request); this.request = request; &#125; @Override public String getParameter(String name) &#123; // 根据请求方式不同,去处理: // 获得请求方式: String method = request.getMethod(); if("get".equalsIgnoreCase(method))&#123; String value = null; try &#123; value = new String(request.getParameter(name).getBytes("ISO-8859-1"),"UTF-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return value; &#125;else if("post".equalsIgnoreCase(method))&#123; try &#123; request.setCharacterEncoding("UTF-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; return super.getParameter(name); &#125;&#125; 过滤器使用装饰后的对象 123456public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; MyHttpServletRequestWrapper myReq = new MyHttpServletRequestWrapper(req); chain.doFilter(myReq, response);&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2FJavaWeb%2FJavaWeb-Ajax%2F</url>
    <content type="text"><![CDATA[Ajax 异步的 javaScript and XML—-异步加载、局部刷新 XMLHttp属性 readyState XMLHttp状态 onreadystatechange 当XMLHttp状态改变时触发一个函数 status 响应状态码 200/404… responseText 响应文本 responseXML 响应xml的数据 方法 open(请求方式,请求路径,是否异步) 创建一个新的http请求，并指定此请求的方法、URL以及验证信息 send(请求参数) 发送请求到http服务器并接收回应 setRequestHeader(头信息,头的值) 单独指定请求的某个http头,处理POSt请求方式中文问题 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function ajax_get() &#123; // 1.创建异步对象 var xhr = createXMLHttp(); // 2.设置状态改变的监听 回调函数. xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; // 请求发送成功 if(xhr.status == 200)&#123; // 响应也成功 // 获得响应的数据: var data = xhr.responseText; // 将数据写入到DIV中: document.getElementById("d1").innerHTML = data; &#125; &#125;&#125;Get方式：// 3.设置请求路径xhr.open("GET","/ServletDemo?name=aaa&amp;pass=123",true);// 4.发送请求xhr.send(null);POST方式:// 3.设置请求路径xhr.open("POST","/ServletDemo",true);xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");// 发送请求:xhr.send("name=张三&amp;pass=123");function createXMLHttp()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; Jquery中的AJax Jquery封装了Ajax操作 Jq的对象.load(路径,参数,回调函数); $.get(路径,参数,回调函数,数据类型); $.post(路径,参数,回调函数,数据类型); $.ajax(); serialize(); – JQ的AJAX传递参数的时候需要使用的方法. 12345678910111213141516171819// Data就是Servlet中response.getWriter().println(1);输出的内容$(function()&#123; $("#username").blur(function()&#123; // 获得文本框的值: var username = $(this).val(); // 演示load方法: // $("#s1").load("/day15/ServletDemo3",&#123;"username":username&#125;); // 演示get/post方法: $.get("/ServletDemo",&#123;"username":username&#125;,function(data)&#123; if(data == 1)&#123; $("#s1").html("&lt;font color='green'&gt;用户名可以使用&lt;/font&gt;"); $("#regBut").attr("disabled",false); &#125;else if(data == 2)&#123; $("#s1").html("&lt;font color='red'&gt;用户名已经存在&lt;/font&gt;"); $("#regBut").attr("disabled",true); &#125; &#125;); &#125;);&#125;);]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Ajax</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp&EL&JSTL]]></title>
    <url>%2FJavaWeb%2FJavaWeb-jsp%26El%26JSTL%2F</url>
    <content type="text"><![CDATA[jsp&amp;EL&amp;JSTLjspJsp概述 Jsp(Java server Pages,Java服务器端页面)，动态网页技术 Jsp运行过程：转换成一个servlet类，编译之后才能运行 JSP嵌入Java代码:JSP的脚本元素 &lt;%! %&gt;:翻译成类中的成员部分. 定义变量,定义方法,定义类.Servlet是线程不安全的,尽量少在类中定义成员属性！！ &lt;% %&gt;:翻译成类的service方法内部的内容. 定义变量,定义类,直接写代码块. &lt;%= %&gt;:翻译成service方法内部的out.print(); JSP的注释JSP的注释: &lt;%-- JSP的注释 --%&gt;HTML注释：只能注释HTML标签 12345&lt;!-- &lt;c:for start=”1” end =”10” &gt; &lt;h1&gt;aaaaa&lt;/h1&gt; &lt;/c:for&gt;--&gt; java注释 只能注释java代码 JSP中有三个指令 JSP中有三个指令:page指令, include指令, taglib指令. JSP的page指令 contentType: 设置浏览器打开这个JSP的时候采用的默认的字符集的编码. pageEncoding: 设置文件保存到本地硬盘,以及生成Servlet后,Servlet保存到硬盘上的编码. import: 在JSP中引入类对象.但是import可以出现多次. 1&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; JSP的include指令: 指示JSP包含其他的页面 1234&lt;%@ include file="logo.jsp" %&gt;&lt;%@ include file="menu.jsp" %&gt;&lt;h1&gt;BODY部分&lt;/h1&gt;&lt;%@ include file="footer.jsp" %&gt; JSP中的taglib指令:指示JSP引入标签库. 1`&lt;%@ taglib uri="标签的URI的路径" prefix="标签的别名" %&gt;` JSP中有9大内置对象 request response session application ServletContext page 当前页面 pageContext config out JspWriter exception JSP的四个域范围 PageScope: 当前页面中有效. pageContext---------&gt; PageContext RequestScope: 一次请求范围. request---------&gt; HttpServletRequest SessionScope: 一次会话范围. session---------&gt; HttpSession ApplicationScope: 整个应用范围 application---------&gt; ServletContext EL 表达式语言 EL的概述:Excepress Language,表达式语言 作用：以最简单的方式操作JSP 使用EL表达式语法:${ EL表达式 } 概括: EL 是从 JavaScript 脚本语言得到启发的一种表达式语言，它借鉴了 JavaScript 多类型转换无关性的特点。在使用 EL 从 scope 中得到参数时可以自动转换类型，因此对于类型的限制更加宽松。 Web 服务器对于 request 请求参数通常会以 String 类型来发送，在得到时使用的 Java 语言脚本就应该是request.getParameter(“XXX”) ，这样的话，对于实际应用还必须进行强制类型转换。而 EL 就将用户从这种类型转换的繁琐工作脱离出来，允许用户直接使用EL 表达式取得的值，而不用关心它是什么类型 获取数据:(JSP的四个域)获取域对象 `${ applicationScope.name }` 访问数组元素 `${ arrs[下标] }` 访问集合 `${ list[下标] }` `${ map.key的值 }` 获取对象的属性 `${ user.id }` 获取对象的集合的数据 `${ userList[0].id }` ==`.`和`[]`的区别== `[]`用于有下标的数据(数组,list集合) `.`用于有属性的数据(map,对象) 如果属性名中包含有特殊的字符.必须使用`[]` 如果EL表达式从四个域对象中没有取到值会返回`&quot;&quot;`, 而不是`null`, 但属性名写错会报错，如 `${user.naaa}` 在书写表达式时，如果没有指定搜索范围，那么系统会依次调用`pageContext`、`request`、`session`、`application`的`getAttribute()`方法。这样不限定查找范围的代码不利于排错，所以这种取值的操作可以先定对象的查找范围。如：`${sessionScope.user.name}` 一旦指定了对象所在的范围，那么只会在范围内查找绑定对象，不会在找不到的时候再去其他区域中查找了。 运算: EL执行算数运算 ${ n1 + n2 } EL执行比较运算 ${ n1 eq n2 } EL执行关系运算 and or not EL执行三元运算 ${ n1 &lt; n2 ? &quot;正确&quot;:&quot;错误&quot; } 判断null ${ empty user }`${ not empty user }`空运算主要用于判断字符串，集合是否为空，是空或为null及找不到值时都会输出true 操作WEB开发的常用的对象`pageScope,requestScope,sessionScope,applicationScope` - 获取JSP中域中的数据 `param,paramValues` - 接收参数. `header,headerValues` - 获取请求头信息 `initParam` - 获取全局初始化参数 `cookie` - WEB开发中cookie `pageContext` - WEB开发中的pageContext. ${ param.id }===request.getPamameter(“id&quot;) 获取Cookie中的值${ cookie.history.value } 调用API：${ pageContext.request.remoteAddr } ${ pageContext.request.contextPath } JSTL 概述JSTL概述：Jsp Standard Tag library,Sun 公司 Java 规范标准的 JSTL 由 apache组织负责维护。作为开源的标准技术，它一直在不断地完善。JSTL 的发布包有两个版本： Standard-1.0 Taglib 、 Standard-1.1 Taglib ，它们在使用时是不同的。 使用JSTL 引入JSTL的相关的jar包. 在页面中引入标签库.&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; 基本语法 12345678910111213 &lt;c:if test="$&#123;&#125;"&gt; .... &lt;/c:if&gt;&lt;% User user = new User(); user.setName("胡萝卜"); user.setGender("f"); request.setAttribute("user",user);%&gt;姓名:$&#123;user.name&#125;&lt;br/&gt;性别:&lt;c:if test="$&#123;user.gender =='m'&#125;" var="rs" scope="request"&gt;男&lt;/c:if&gt;&lt;c:if test="$&#123;!rs&#125;"&gt;女&lt;/c:if&gt; JSTL的forEach标签 加强For: var=&quot;i&quot; items = “{被遍历的对象}&quot; 普通for: var =&quot;i&quot; begin=&quot;开始数据&quot; end=&quot;结束数据&quot; step=&quot;步数&quot; varstatus=&quot;&quot; 统计循环的个数 举例:其中items属性为要遍历的集合，var属性为每次取出来的一个对象，varStatus指定当前迭代的状态 1234567891011121314&lt;table&gt; &lt;tr&gt; &lt;td&gt;序号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;users&#125;" var="u" varStatus="s"&gt; &lt;tr&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;u.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;u.age&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaweb会话技术]]></title>
    <url>%2FJavaWeb%2FJavaWeb-Cookie%26Session%2F</url>
    <content type="text"><![CDATA[会话技术 会话: 用户打开一个浏览器访问页面,访问网站的很多页面,访问完成后将浏览器关闭的过程称为是一次会话. 常见的会话技术: Cookie :将数据保存到客户端浏览器. Session :将数据保存到服务器端. URL重写 隐藏表单域 hidden Cookie 向浏览器保存数据: HttpServletResponse有一个方法:void addCookie(Cookie cookie);获得浏览器带过来的Cookie:HttpServletRequest有一个方法:Cookie[] getCookies();创建一个Cookie对象:Cookie(String name,String value); Cookie常用API getName(); –获取Cookie的名称 getValue(); –获取Cookie的值 setDomain(String domain); – 设置Cookie的有效域名. setPath(String path); – 设置Cookie的有效路径. setMaxAge(int maxAge); – 设置Cookie的有效时间. setMaxAge如果咱们不手动设置值它的默认值是-1,即为临时Cookie 如果想删除一个cookie的话就给它设置为0 如果给它设置为一个正数值,代表就是它的存活时间 60 * 60 * 24 * 7 如果是相同path和相同domain下相同的cookie name会覆盖 Cookie的分类 会话级别的Cookie:默认的Cookie.关闭浏览器Cookie就会销毁. 持久级别的Cookie:可以设置Cookie的有效时间.那么关闭浏览器Cookie还会存在. 手动销毁持久性Cookie.setMaxAge(0)(前提是有效路径必须一致) 示例:显示商品浏览记录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class ProductServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 接收id: String id = request.getParameter("id"); // 获得所有的Cookie的信息: Cookie[] cookies = request.getCookies(); // 判断是否是第一次: Cookie cookie = CookieUtils.findCookie(cookies, "history"); if(cookie == null)&#123; // 第一次浏览商品 Cookie c = new Cookie("history",id); c.setPath("/xxx"); c.setMaxAge(60*60*24*7); response.addCookie(c); &#125;else&#123; // 不是第一次浏览 // 判断选择的商品是否已经在浏览记录中 2-1 String value = cookie.getValue(); String[] ids = value.split("-"); // 将数组变为集合： LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;(Arrays.asList(ids)); if(list.contains(id))&#123; // 之前浏览过该商品 list.remove(id); // 1-2-3 list.addFirst(id); &#125;else&#123; // 没有浏览过该商品. if(list.size() &gt;=3 )&#123; // 超过3个 list.removeLast(); list.addFirst(id); &#125;else&#123; // 没到3个. list.addFirst(id); &#125; &#125; // 将list中的元素取出,使用-连接上保存到Cookie,写回浏览器. StringBuffer sb = new StringBuffer(); for(String s:list)&#123; sb.append(s).append("-"); &#125; String sValue = sb.toString().substring(0,sb.length()-1); System.out.println(sValue); // 存入到Cookie中 Cookie c = new Cookie("history",sValue); c.setPath("/xxx"); c.setMaxAge(60*60*24*7); response.addCookie(c); &#125; request.getRequestDispatcher("/xxx/product_info.htm").forward(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; Session 基于Cookie的JSESSIONID 获得Session:request.getSession();/request.getSession(boolean) Cookie与Session的区别Cookie本身是有大小和个数的限制.大小一般不超过4KB, 个数的不超过20个,Session没有限制.Cookie的数据保存在客户端,Session数据保存在服务器端.Cookie被禁止了，默认session也不能使用 存储位置Cookie存储在浏览器客户端 Session存储在服务器内存中 Cookie有大小限制 Session是没有大小限制 Cookie只能存储String Session可以存储object 获取Cookie newCookie(String String) 获取Session req.getSession() Session是域对象 Cookie不是域对象 Session是依赖于Cookie session作为域对象存取数据session的创建和销毁 创建: 服务器端第一次调用getSession()创建session.，以后调用getSession获得同一个 销毁:三种情况销毁session: session过期. 默认过期时间为30分钟. 在Tomcat设置：所有的项目的session 在某个项目中的web.xml设置：当前工程的所有session给某个session对象设置：对应的session对象setMaxInactiveInterval(int interval) 非正常关闭服务器.如果正常关闭session序列化到硬盘. 手动调用session.invalidate(); 作用范围:多次请求.(一次会话) ==Servlet中的域对象：request,session,ServletContext== request:范围一次请求，转发时能够共享数据,一个请求对应一个 session:一次会话（包含多次请求与响应），转发与重定向都能共享,一个用户对应一个 ServletContext:一个项目都有效，包含多个会话 共同的特点：存储数据 `setAttribute()/getAttribute()/removeAttribute()` `Cookie, new Cookie(String,String)` `session, setAttribute(String,Object)` Session总结作用：域对象存储数据 `setAttribute()/getAttribute()` 创建：在第一次访问`(request.getSession())session` 销毁：三种方式 设置session生存时间，默认在tomcat中有配置 web.xml: 1234567&lt;session-config&gt; &lt;session-timeout&gt;30min&lt;/session-timeout&gt;&lt;/session-config&gt;配置当前工程web.xml：&lt;session-config&gt; &lt;session-timeout&gt;60&lt;/session-timeout&gt;&lt;/session-config&gt; 配置单个session：`setMaxInActiveInterval(s)` 范围：session：一次会话有效（多次请求响应）]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet 二]]></title>
    <url>%2FJavaWeb%2FJavaWeb-Servlet%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[#Servlet 一 读取WEB工程下的文件1234// 传统方式,不适用web工程InputStream is = new FileInputStream("src/db.properties");Properties properties = new Properties();properties.load(is); 1234567891011121314151617// 使用类的加载器来读取文件.// 类的加载器用来加载class文件,将class文件加载到内存.InputStream is = ReadFileUtils.class.getClassLoader().getResourceAsStream("db.properties");Properties properties = new Properties();properties.load(is);//web方式`ServletContext. getResourceAsStream("/WEB-INF/classes/db.properties");`通过相对路径获得绝对路径`String realPath = context.getRealPath("/WEB-INF/classes/db.properties");`// 获得该文件的磁盘绝对路径.`InputStream is = new FileInputStream(realPath);` ServletContext功能概述 读取全局初始化参数 ServletContext.getInitParameter() 读取web.xml中的参数 ServletConfig.getInitParameter() 读取servlet标签中配置的参数 获得文件的MIME的类型 MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开文件下载，设置mime类型，浏览器自动使用指定应用程序来打开 ServletContext.getMimeType(“xxxxx.jpg”); 作为域对象存取数据setAttribute(key,Object)/getAttribute(key) ServletContext对象 创建时间：服务器启动的时候创建，一个项目有且仅有一个ServletContext对象 销毁时间：服务器关闭或者项目移除 读取web项目下的文件 默认读取项目根路径下的文件ServletContext.getResourceAsStream(“路径”) 通过相对路径动态获得根盘符的绝对路径ServletContext.getRealPath(“路径”) 文件下载功能输出中文字符：`response.setContentType(“text/html;charset=UTF-8”);` 字符流: `response.getWriter()` 字节流：`response.getOutputStream()` (做文件下载) 1234567891011// 2.1设置Content-Type头String type = this.getServletContext().getMimeType(filename);response.setHeader("Content-Type", type);// 2.2设置Content-Disposition头response.setHeader("Content-Disposition","attachment;filename="+filename);// 2.3设置文件的InputStream.//realPath = this.getServletContext().getRealPath("/download/"+filename);//InputStream is = new FileInputStream(realPath);InputStream is = this.getServletContext.getResourceAsStream("/download/"+filename)// 获得response的输出流:OutputStream os = response.getOutputStream(); Request对象 Request对象的功能 1.获得客户端的信息 `String getRequestURI()` `StringBuffer getRequestURL()` 2.获得请求参数 `getParameter(key)` 3.域对象，存储数据 `setAttribute(key,Object)` `getAttribute()` 4.转发 `request.getRequestDispatcher(&quot;/demo1-download/login.jsp&quot;).forward(request, response);` response对象 重定向response.sendRedirect(路径) 输出字符串response.getWriter().println(字符串) 设置各种响应头的信息response.setContentType(“text/html;charset=utf-8”)下载设置文件的显示方式 response.setHeader(“Content-disposition”,”attachement;filename=xxx.xx”) ##转发与重定向的区别 重定向的地址栏会发生变化,转发的地址栏不变 重定向两次请求两次响应,转发一次请求一次响应. 重定向路径需要加工程名,转发的路径不需要加工程名. 重定向可以跳转到任意网站,转发只能在服务器内部进行转发. 重定向不能使用request域存储数据，转发可以使用request存储数据 中文乱码的解决接收中文乱码 get方式 `new String(String.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);` post方式 `request.setCharacterEncoding(“UTF-8”)` 输出中文乱码 字符流 设置`response.setContentType(&quot;text/html;charset=UTF-8&quot;);` 字节流 `response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);` // 设置浏览器默认打开的时候采用的字符集编码 `response.getOutputStream().write(&quot;中文&quot;.getBytes(&quot;UTF-8&quot;));` // 设置中文转成字节数组的时候取出的编码]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet 一]]></title>
    <url>%2FJavaWeb%2FJavaWeb-Servlet%2F</url>
    <content type="text"><![CDATA[#Servlet 一 主要点 servlet的生命周期 url-pattern的配置 路径问题 ServletContext对象 Servlet 实现类 Servlet :接口 GenericServlet :通用的Servlet HttpServlet :处理http协议的Servlet Servlet的生命周期 对象从创建到销毁的过程 Servlet生命周期: Servlet从创建到销毁的过程. 何时创建:用户第一次访问Servlet创建Servlet的实例, 只会被创建一次, 所以是单例何时销毁:当项目从服务器中移除的时候，或者关闭服务器的时候. ==用户第一次访问Servlet的时候,服务器会创建一个Servlet的实例,那么Servlet中init方法就会执行.任何一次请求服务器都会创建一个新的线程访问Servlet中的service的方法.在service方法内部根据请求的方式的不同调用doXXX的方法.(get请求调用doGet,post请求调用doPost).当Servlet中服务器中移除掉,或者关闭服务器,Servlet的实例就会被销毁,那么destroy方法就会执行.== Servlet生命周期分为三个阶段，初始化阶段，运行阶段，销毁阶段 初始化阶段默认在Servlet第一次被访问的时候执行，调用init方法执行一些初始化准备工作。浏览器每次发起请求则执行运行阶段调用service方法，执行具体业务流程。当服务器关闭或者项目被移除执行销毁阶段，调用destory方法，可以在destory方法中执行资源回收，连接关闭等工作。 初始化阶段和销毁阶段在整个生命周期过程中只执行一次，运行阶段可以执行多次 Servlet的配置Servlet默认是在第一次访问的时候创建的.现在让Servlet在服务器启动的时候创建好.进行对Servlet的配置:在web.xml中在&lt;servlet&gt;&lt;/servlet&gt;标签中配置:&lt;load-on-startup&gt;2&lt;/load-on-startup&gt; 传入正整数,整数越小,被创建的优先级就越高. url-pattern配置方式共有三种: 完全路径匹配 ：以 / 开始&lt;url-pattern&gt;/ServletDemo1&lt;/url-pattern&gt; 目录匹配 ：以 / 开始需要以 结束.`/aaa/` 扩展名匹配 ：不能以 / 开始 以 开始的. `.action` ==错误的写法 ：/*.do== structs2默认的是以.action为后缀，springmvc是以.do为后缀 Servlet路径编写 相对路径:都是需要找位置相对关系.不能以 / 开始的 ./ 当前路径 ../上一级目录使用相对路径访问: 绝对路径:不需要找位置相对关系. 以 / 开始的.绝对路径中分为客户端路径和服务器端路径: 客户端路径一定要加工程名. 服务器端路径不需要加工程名. ServletContext对象ServletContext对象存取数据,存的数据都是有一定的作用的范围的.这种对象称为是域对象.所有的Servlet都在ServletContext环境下(每一个项目有且只有一个ServletContext对象)ServletContext存取数据:存入数据:setAttribute(key,value)获取数据:Object getAttribute(key)移除数据:removeAttribute(key) ServletContext的作用: 用来获得全局初始化参数. 用来获得文件的MIME的类型. 作为域对象存取数据.(ServletContext是一个域对象) 作用范围:整个web工程. 创建:服务器启动的时候,tomcat服务器为每个web项目创建一个单独ServletContext对象. 销毁:服务器关闭的时候,或者项目从服务器中移除的时候. 用来读取web项目下的文件. ServletConfig 对象 1234567ServletConfig servletConfig = this.getServletConfig();String servletName = servletConfig.getServletName();System.out.println(servletName);String username = servletConfig.getInitParameter("username");String password = servletConfig.getInitParameter("password");System.out.println(username+" "+password); 123456789101112&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo7&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.a_servlet.ServletDemo7&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql]]></title>
    <url>%2FJavaWeb%2FJavaWeb%20-Mysql%2F</url>
    <content type="text"><![CDATA[Mysql基本概念是一个文件系统,存储数据,通过标准的SQLy语句获取数据 关系型数据库关系型数据库存放的是实体之间的关系 常见关系型如:mysql orcale db2 mysql 安装注意路径不能有空格 中文等 数据存储方式数据库服务器 --&gt;数据库 ---&gt;表(为每个实体创建一个表)--&gt;字段 一台数据库服务器中会创建很多数据库（一个项目，会创建一个数据库）。在数据库中会创建很多张表（一个实体会创建一个表）。在表中会有很多记录（一个对象的实例会添加一条新的记录）。 graph TB 数据库服务器--&gt;数据库1 数据库服务器--&gt;数据库2 数据库1--&gt;表1 数据库1--&gt;表2 数据库2--&gt;表3 数据库2--&gt;表4 eg:表结构(table)id | name |age—|—|—1 | 张三 |132 | 李四 |15 netstat -ano 端口查看 tasklist /svc 任务列表 ipconfig /flushdns ip刷新 sql 结构化查询语言分类:DDL 数据定义语言 数据库/表的操作 create drop altet DCL 数据控制语言 grant if DML 数据操作语言 对数据进行操作 insert updata delete DQL 数据查询语言 select 数据库操作创建数据库CREATE DATABASE 数据库名称 CHARACTER SET 字符集 COLLATE 字符集校对规则 eg: CREATE DATABASE; //字符集和校对规则可省略 查看数据库 SHOW DATABASES; 查看某个数据库的定义信息： SHOW CREATE DATABASE 数据库名称; 修改数据库 修改数据库字符集 ALTER 数据库名 CHARACTER SET 字符集; 删除数据库 DROP DATABASE 数据库名; 切换使用的数据库 use 数据库名; 查看正在使用的数据库 select database(); 数据类型表中字段类型 Java中的类型 MySQL中的类型 byte/short/int/long tinyint/smallint/int/bigint float float double double boolean bit char/String char和varchar类型 //需要指定长度 Date date/time/datetime/timestamp File blob/text //很少用 注意:在mysql中 char代表是固定长度的字符或字符串 eg:char(8) 存入长度不够8用空格不齐 varchar代表的是可变长度的字符串 eg: varchar(8) 长度不够8不会不齐 datetime就是既有日期又有时间的日期类型,如果没有向这个字段中存值，数据库使用null存入到数据库中 timestamp也是既有日期又有时间的日期类型，如果没有向这个字段中存值，数据库使用当前的系统时间存入到数据库中 表的操作 创建表CREATE TABLE 表名(字段名称 字段类型(长度) 约束,字段名称 字段类型(长度) 约束…); 12345678910111213141516171819202122eg:CREATE TABLE person&#123; id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(10) UNIQUE, age INT&#125;;注意: 创建表之前要有数据库并使用数据库 约束可省略约束 主键 PRIMARY KEY 默认非空唯一 非空 NOT NULL 唯一 UNIQUE查看所有表 SHOW TABLES;查看某个表的结构信息 DESC 表名;查看表创建信息 SHOW CREATE TABLE 表名;删除表DROP TABLE 表名; 修改表 1）添加列ALTER TABLE 表名称 ADD 列名 类型(长度) 约束; 12eg: ALTER TABLE t_address ADD phone VARCHAR(20); 2)修改列的类型、长度、约束 ALTER TABLE 表名称 MODIFY 类型(长度) 约束; eg： ALTER TABLE t_address MODIFY phone VARCHAR(30) NOT NULL; 3)修改列名 ALTER TABLE 表名称 CHANGE 旧列名 新列名 类型(长度) 约束; eg： ALTER TABLE t_address CHANGE phone tel VARCHAR(30) NOT NULL; 4)删除列 ALTER TABLE 表名称 DROP 列名; eg: ALTER TABLE t_address DROP tel; 5)修改表名RENAME TABLE 表名 TO 新表名; 插入数据 1)INSERT INTO 表名(列名1,列名2,...,列名N) VALUES(值1,值2,...,值N); 2)INSERT INTO 表名(列名1,列名2,...,列名N) VALUES(值1,值2,...,值N),(值1,值2,...,值N),...,(值1,值2,...,值N); 3)INSERT INTO 表名 VALUES(值1,值2,...,值N); 更新数据 UPDATE 表名 SET 列名1=值1,列名2=值2,...,列名n=值n WHERE 条件; 删除数据 1)删除部分数据 DELETE FROM 表名 WHERE 条件; 2)删除表内所有数据 --DELETE是一条条删除，不会清空AUTO_INCREMENT DELETE FROM 表名; --属于DML,事务可以作用在DML上 --直接将表删除，重建，AUTO_INCREMENT重置为0 TRUNCATE TABLE 表名; --属于DDL 查询数据 基本查询 SELECT * FROM 表名 ; --查询所有 SELECT 列名1,列名2... FROM 表名 ; --查询指定列数据 SELECT DISTINCT 列名1... FROM 表名 ; --去重查询,参数所有列完全相同时去重 SELECT 列名1 AS 列名1别名,列名2 AS 列名2别名 FROM 表名 ; --别名查询,AS可以省略 条件查询 基本查询+WHERE 条件; SELECT * FROM 表名 WHERE 条件; 条件: &gt;, &lt; ,&gt;=, &lt;= ,&lt;&gt;, = like 模糊查询,使用_或%作为站位符,_代表一个字符,%代表任意个字符 in 范围查询 匹配内容 between .. and and ,or ,not eg: SELECT * FROM headset WHERE name LIKE &apos;李_&apos;; SELECT * FROM headset WHERE age IN(21,22,23); SELECT * FROM headset WHERE money BETWEEN 1000 AND 1800; 排序查询 order by 字段名 asc(升序默认可省略)/desc(降序); eg: select * from exam order by score; select * from exam order by score desc; select * from exam order by score desc,age asc; 分页查询 sql语句最后 limit 起始index,数目 聚合函数 count max/min sum avg eg: SELECT sum(english) from exam where name like &apos;李%&apos;; ifnull(字段,默认值) --当字段为空时以默认值计算 分组查询 SELECT 字段 ,COUNT(*) FROM 表名 GROUP BY 字段; 聚合函数通常和分组配合, where 后不能跟聚合函数 需要用having SELECT 字段 ,SUM(字段1) FROM 表名 GROUP BY 字段 HAVING 条件; 总结 S(select)… F(from)…W(where)…G(group by)…H(having)…O(order by); 多表约束外键约束:保证数据的完整性 alter table 表 add foreign key(字段) references 表a(字段a) 外键一般连接的都是主键 多表关系一对一 一的其中一方创建外键指向另一方的主键 主键绑定主键 一对多 多的一方创建外键指向一的主键 多对多 需要创建第三张表(中间表),在中间表中能够至少有两个字段作为外键分别指向多对多双方主键 多表查询连接查询交叉连接(了解) 两个表的笛卡尔积 select * from 表1 cross join 表2; select * from 表1 , 表2; 内连接 显示内连接 inner join (inner 可省略) select * from 表1 inner join 表2 on 关联条件; 隐士内连接 select * from 表1,表2 where 关联条件; 外连接 outer join (outer 可省略) 左外连接 select * from 表1 left outer join 表2 on 关联条件 右外连接 select * from 表1 right outer join 表2 on 关联条件 子查询一个查询语句需要依赖另一个查询语句的结果 查询中嵌套查询 in any 任意一个 all 所有 exists select * from clsses where exists(selct cno from student where birthday&gt;&apos;1991-01-01&apos;) 事务 特性 原子性 事务不可分割 一致性 事务执行的前后,数据的完整性保持一致 隔离性 一个事务的执行不应该受到其他事务的干扰 持久性 事务一旦提交结束 就因该保存到数据库中 开启事务 start transaction 提交事务 commit 回滚事务 rollback 隔离级别 基于隔离性出现的问题 脏读 一个事务查询到另外一个事务未提交的数据,导致查询结果不一致 不可重复读 一个事务读到了到另外一个事务已提交的update数据,导致多次查询结果不一致 虚读/幻读 一个事务读到了到另外一个事务已提交的insert数据,导致多次查询结果不一致 级别 read uncommitted read committed repeatable serializable JDBCjava数据连接 一组Java语言的类和接口 规范 驱动:两设备(应用)之间的通信桥梁 步骤 注册驱动 Class.forName(“com.mysql.jdbc.Driver”); 获取连接对象 Connection con=DriverManager.getConnection(“jdbc:mysql://ip地址:端口/数据库名称”,数据库用户名,数据库密码); 获得一个操作sql对象 Statement sm= con.createStatement; 执行sql语句 获取结果 String sql =”sql语句”; ResultSet set=sm.executeQuery(sql); 查询 int row =sm.executeUpdate(sql); 增删改 处理结果 释放资源 set.close(); sm.close(); con.close() 1234567891011121314151617eg:if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException sqlEx) &#123; // ignore &#125; rs = null;&#125;if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException sqlEx) &#123; // ignore &#125; stmt = null;&#125; JDBC 的sql 注入漏洞把用户输入得参数当作sql关键字被解释执行 jdbc事务 环境准备 数据库及表 create database web_test; use web_test; create table account( id int primary key auto_increment, userName varchar(20), password varchar(20), money double ); insert into account values(null,zhangsan,12345); 开启事务 conn.setAutoCOmmit(false);//关闭自动提交 提交事务conn.commit(); 事务回滚conn.rollback(); 代码12 连接池创建和管理一个连接的缓存池的技术 连接的创建和销毁需要时间,在服务器初级化时就初始化一些连接放入连接池中,使用时可从内存中获取,在内存中效率高 自定义连接池 装饰着模式 Druid连接池 DuridDataSource ds =new DuridDataSource(); //手动 ds.setDriverClassName(“”); ds.setUrl(“”); ds.setPassword(“”); //配置文件方式 /* DriverClassName= url= username= password= */ Properties prop= new Properties() prop.load(InputStream) DruidDataSourceFaxtory.createDataSource(prop) //获得连接 ds.getConnection(); c3p0连接池 ComboPooledDataSource ds =new ComboPooledDataSource(); ds,setDriverClass(“”); ds.setJdbcUrl(“”); ds.setUser(“”); ds.setPassword(“”); //获得连接 ds.getConnection(); DBUtils 对jdbc简单的封装而没有影响性能]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2FJavaWeb%2FJavaWeb%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTML Hyper Text Markup Language 超文本标记语言 标记语言：指的是通过一组标签的形式描述事物的一门语言用于制作页面（静态） 结构 一个HTML文件后缀名为.html 或 htm 123456789101112131415&lt;!-- 根标签--&gt;&lt;html&gt;&lt;!-- 头标签 基于当前页面的一些配置--&gt;&lt;head&gt;&lt;title&gt;html 标题&lt;/title&gt;&lt;!-- 配置字符集 seo优化--&gt;&lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;!-- 体标签 展示内容--&gt;&lt;body&gt;html body&lt;/body&gt;&lt;/html&gt; 标签分类 按标签写法 双边 &lt;body&gt;&lt;/body&gt; 单边 &lt;br /&gt; 按状态 行内 &lt;span&gt; 块级 &lt;div&gt; HTML 字体排版标签1234567891011121314151617&lt;font&gt; 字体便签&lt;font color="red" size="12" face="宋体"&gt;&lt;/font&gt;属性 color 字体颜色英文单词 red black..使用16进制 #FFFFFF , #FFFF属性 size 字体大小从1 到 7属性 face 字体&lt;br /&gt; 换行标签&lt;h1 &gt;&lt;/h1&gt; 标题标签 ... &lt;h6&gt;&lt;/h6&gt;&lt;p&gt;&lt;/p&gt; 段落标签&lt;b&gt; &lt;/b&gt; 字体加粗&lt;i&gt;&lt;/i&gt; 斜体标签&lt;u&gt;&lt;/u&gt; 下划线标签&lt;center&gt; &lt;/center&gt;内容居中&lt;hr&gt;&lt;/hr&gt; 分隔线&lt;pre&gt;&lt;/pre&gt; 预定义标签 将字符串原封不动的显示出来 HTML 图片标签 &lt;img&gt; 图片标签 属性 src ： 图片来源 width : 图片的宽度. height: 图片的高度. alt : 图片找不到显示的内容. 12eg:&lt;img src="a.png" width=100% height=100% alt="img"/&gt; HTML 列表标签 无序 ul li 属性 type 类型 circle 空心点 disc 实心点 默认 square 方块 1234&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 有序 ol li 属性type 类型 1 数字型 a 英文型 i 罗马字符型 start 从哪个开始 1234&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 超链接标签 &lt;a&gt; 属性 href :链接的路径 target :打开的方式 _self :在自身页面打开 _blank :新打开一个页面 table标签12345&lt;table&gt;&lt;tr&gt;&lt;!--行--&gt;&lt;td&gt;&lt;/td&gt; 列&lt;/tr&gt;&lt;/table&gt; 属性width ； 表格宽度height：表格高度border ： 边框Align: 水平位置leftrightcenter 属性合并单元格colspan=”列数”rowspan=”行数” 表单标签 &lt;form&gt; action 提交的路径，默认当前页面 method 请求方式，GET 和POST 默认为GET 表单中的元素&lt;input&gt; 文本框 &lt;input type=&quot;text&quot;/&gt; 文本框 属性 type： 类型 text 文本框 password 密码框 radio 单选按钮 checkbox 复选按钮 button 普通按钮 submit 提交按钮 reset 重置按钮 file 文件上传的表单项 hidden 隐藏字段 image 图片按钮 name: 表单元素名称 必须有 value: 文本框默认值 size: 文本框长度 maxlength: 最大输入长度 readonly: 只读 checked: 单选/复选按钮默认选中 &lt;select&gt; 下拉列表 name 属性 &lt;option&gt; value 属性 #####&lt;textarea&gt; 文本域 cols rows 框架标签 frameset 注意 与body 标签冲突 属性 rows cols 两者只能出现其一 使用&lt;frame&gt; 标签 frame代表分切的每个部分 属性 src 网页的连接 name 指定名称 可以通过a标签跳转 onresize 让frame边框不能拖动 1234567&lt;frameset rows=2&gt;&lt;frame&gt;&lt;/frame&gt;&lt;frameset cols=2&gt;&lt;frame&gt;&lt;/frame&gt;&lt;frame&gt;&lt;/frame&gt;&lt;/frameset&gt;&lt;/frameset&gt; css 层叠样式 div +css 页面布局 对页面进行美化 块标签&lt;div&gt;&lt;/div&gt; ： 默认一个独占一行 行内标签&lt;span&gt;&lt;/span&gt; : 默认不换行 基本语法引入方式####行内式 直接标签内使用style 属性&lt; h1 style=&quot;color:red;&quot;&gt;&lt;/h1&gt; ####内联式 使用style标签,一般放在head 标签内 12345&lt;style&gt;h1&#123;color:red;&#125;&lt;/style&gt; ####外联式 单独定义.css文件在HTML中link标签中引入 123456.css文件中h1&#123;color:red;&#125;html中 使用link 标签&lt;link href=&quot;.css文件路径&quot; type=&quot;text/css&quot; /&gt; 选择器声明 属性:值 选择器{属性:值;属性:值…} 元素选择器 根据标签名称 div{} ####id选择器 根据标签id属性值 _id #_id{} 类选择器 根据标签class属性值 _class ._class{} 其他选择器属性选择器eq: input[type=&quot;text&quot;]{ } 后代选择器div span{} 查找所有div 中的所有span标签 #####子元素选择器 div &gt; span{} 查找所有div 中的第一层是span标签 相邻选择器div + span{} 并列选择器选择器1,选择器2{} 浮动CSS float 属性 值 描述 left 元素向左浮动。 right 元素向右浮动。 none 默认值。元素不浮动，并会显示在其在文本中出现的位置。 inherit 规定应该从父元素继承 float 属性的值。 清除浮动 使用clear 属性 1234&lt;div style="float:'left'"&gt;&lt;div&gt;&lt;div style="clear :'none'"&gt;&lt;div&gt; 定位position 绝对定位 absolute 相对定位 relative 盒子模型 内边距 pedJSKSJding 边框 border 外边距 margin JS 脚本语言 ##组成 ECMAScript: 基本语法 DOM document object model 文档对象模型 BOM browser object model 浏览器对象模型 ##语法区分大小写 ###弱变量类型语言(与java不同) 变量命名 var i =3;//整数型 var i =”3”;//字符串类型 ###数据类型 undefined 未定义 boolean number string object ###运算符 与Java中基本一致 js中=== 全等 类型和值都一致才为true 语句与Java语句一致 ##开发步骤 通常由一个事件触发 事件触发后引用函数 调用函数 定义函数function 函数名(){ 函数体 } 匿名函数 window.onload=function(){}常用事件 onclick 点击事件 onsubmit 提交 onchange select选中 onfocus 获得焦点 onblur 失去焦点 onload 页面加载 12345eg:var br=doucment.getElementById(&quot;id&quot;);br.onclik(function()&#123;//...&#125;); js引入方式使用script 标签&lt;script&gt; js内容 &lt;/script&gt; 引入.js 文件&lt;script src=&quot;js文件&quot;&gt;&lt;/script&gt; 正则&quot;&quot;.match(/正则表达式/) /正则表达式/.test(&quot;&quot;) ##获得页面元素 document.getElementById(“id”); window中setTimeout(一定时间后执行) setInterval(每隔一定时间执行) eg: setInterval(function(){ },1000); setTimeout(function(){ },1000); JQuery 一个js 的框架(类库) ##引入 $(function(){ //$相当于JQuery 对象 //等页面的Dom树绘制完成后执行 }); js/jq对象转换###js对象转jq对象 $(js对象) ###jq对象转js对象 var $d1=$(“#id”);//jq对象 $d1 变量名可起其他名 #id 为 #+标签id eq: var a =$(#id); $d1[0];或 $d1.get(0);//转为js对象 ##显示与隐藏 $(选择器).show(); $(选择器).hide(); $(选择器).toggle(); 当标签隐藏时显示,显示时隐藏 用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。 如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。 ###基本 show([speed,[easing],[fn]]) hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) ###滑动 slideDown([spe],[eas],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 注意要设置标签的宽度 ###淡入淡出 fadeIn([speed],[eas],[fn]) fadeOut([speed],[eas],[fn]) fadeTo([[spe],opa,[eas],[fn]]) fadeToggle([speed,[eas],[fn]]) ##选择器 $(选择器) ###基本 #id id选择器 .class 类选择器 元素名 元素选择器 * 通配选择器 选择器1,选择器2 并列选择器 层级选择器ancestor descendant 后代选择器 使用空格 eg: $(body div) body 下的所有的div标签 parent &gt; child 子元素选择器 使用&gt; eg:$(body&gt;div) body下的第一层div标签 prev + next 下一个元素 使用+ eg:$(#id+div) id标签的下一个标签 prev ~ siblings 兄弟元素 使用~ eg:$(#id~div) id标签的所有兄弟标签 基本过滤:first 第一个元素 :last 最后一个元素 :odd 奇数元素 :even 偶数元素 :eq(index) 下标为index 元素 内容过滤 :contains(text) 内容为text的元素 属性[attribute] [attribute=value] 匹配给定的属性是某个特定值的元素 [attribute!=value] 匹配所有不含有指定的属性，或者属性不等于特定值的元素 [attribute^=value] 匹配给定的属性是以某些值开始的元素 [attribute$=value] [attribute*=value] [attrSel1][attrSel2][attrSelN] 表单选择器和表单属性选择器:input 所有的表单标签 checked checkbox 或 radio 被选中 selected select被选中 添加和移除样式* 如果样式没有事先定义,可以使用css方法为奇数行或者偶数行设置背景颜色. css(&quot;属性&quot;,&quot;值&quot;) css(&quot;属性1:值1&quot;,&quot;属性2:值2&quot;) * 如果已经在css文件中事先将样式定义完成了,不能使用css方法了.使用JQ中的CSS类中的方法： * addClass(); * removeClass(); eg: $(&quot;tr&quot;).addClass(&quot;&quot;); 标签属性操作attr(); 高版本会失效 prop(); 获取设置属性 prop(&quot;属性&quot;) prop(&quot;属性&quot;,&quot;值&quot;) removeProp() 移除属性 操作文档对象 append() 添加 appendTo() 添加到 html() 替换内容 遍历$().each(function(i,n){ // i代表index ,n代表当前元素 }) $.each(数组,function(i,n){}) 事件切换toggle(); 用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。 如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。 eg: 对表格切换显示/隐藏 $(&apos;td).toggle(); 对表格的切换一个类 $(&quot;td&quot;).toggle( function () { $(this).addClass(&quot;selected&quot;); }, function () { $(this).removeClass(&quot;selected&quot;); } ); trigger和triggerHandler的区别1.trigger和triggerHandler都会触发自己实现的逻辑 2.trigger会导致系统的事件和自己定义的逻辑都被触发 3.triggerHandler只会触发自己实现的逻辑,不会触发系统的事件 4.trigger会对所有匹配到的元素都执行相关逻辑 5.triggerHandler他只会对匹配到的元素的第一个执行自己的逻辑,并且不会执行系统的事件 6.trigger会导致事件冒泡.triggerHanlder不会导致事件冒泡 BootStrap 前端响应式框架 引入bootstrap文件 注意先引入jquery在引入bootstrap.js 1234&lt;link rel="stylesheet" href="css/bootstrap.min.css" /&gt;&lt;link rel="stylesheet" href="css/bootstrap-theme.min.css" /&gt;&lt;script type="text/javascript" src="js/jquery-1.8.3.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/bootstrap.min.js"&gt;&lt;/script&gt; 添加&lt;meta&gt;标签&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 全局css布局容器.container .container-flue 栅格系统12列 .row 行 .col-lg-n .col-md-n .col-sm-n .col-xs-n 四种列样式,n是数字1-12代表占行的份额,行的总份额为12 12345678910eg:&lt;body&gt;&lt;div class="container"&gt;&lt;div class="row"&gt;&lt;div class="col-md-4"&gt;&lt;/div&gt;&lt;div class="col-md-4"&gt;&lt;/div&gt;&lt;div class="col-md-4"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; javaScript插件轮播]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http]]></title>
    <url>%2FJavaWeb%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP协议 超文本传输协议,用来规定浏览器和服务器之间要遵守的协议 特点 基于请求和响应的模型 必须现有请求后有响应 请求和响应成对出现 协议详解TCP/IPTCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，定义了主机如何连入因特网及数据如何再它们之间传输的标准，从字面意思来看TCP/IP是TCP和IP协议的合称，但实际上TCP/IP协议是指因特网整个TCP/IP协议族。不同于OSI模型的七个分层，TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等传输层：TCP，UDP网络层：IP，ICMP，OSPF，EIGRP，IGMP数据链路层：SLIP，CSLIP，PPP，MTU每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的建立TCP连接的三次握手 Socket套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议， 本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。 httpHttp协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。在HTTP 1.0中客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。虽然这里使用TCP连接保持了一段时间，但是这个时间是有限范围的，到了时间点依然是会关闭的，所以我们还把其看做是每次连接完成后就会关闭。Http连接是一种短连接，是一种无状态的连接。所谓的无状态，是指浏览器每次向服务器发起请求的时候，不是通过一个连接，而是每次都建立一个新的连接。如果是一个连接的话，服务器进程中就能保持住这个连接并且在内存中记住一些信息状态。而每次请求结束后，连接就关闭，相关的内容就释放了，所以记不住任何状态，称为无状态连接。如果要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即使不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。通过Session, Cookie等相关技术，也能保持一些用户的状态。但是还是每次都使用一个连接，依然是无状态连接。Http协议指定的端口是 80，所以一般计算机上不会限制这个端口，所以Http协议能够顺利通过所有机器上的防火墙。 HTTP，socket，TCP/IP：网络由下往上分为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层，三者从本质上来说没有可比性socket则是对TCP/IP协议的封装和应用(程序员层面上)。TPC/IP协议是传输层协议，主要解决数据如何在网络中传输HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。如果想要使传输的数据有意义，则必须使用到应用层协议。应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。通过Socket，我们才能使用TCP/IP协议。实际上，Socket跟TCP/IP协议没有必然的联系。Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。关于socket和TCP/IP协议关系的说法比较容易理解：“TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。”有个比较形象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。 状态码 200 ：成功 302 ：重定向 304 ：查找本地缓存 404 ：资源不存在 500 ：服务器内部错误更多状态码]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat]]></title>
    <url>%2FJavaWeb%2FWEB%E5%B7%A5%E7%A8%8B-Tomcat%2F</url>
    <content type="text"><![CDATA[Tomcat发布一个WEB工程##常见WEB服务器 Apache :发布PHP的. LAMP:Linux Apache MySQL PHP. IIS :发布ASP的. WebSphere、WebLogic、Jboss Nginx ， Tomcat Apache组织研发,免费的小型的服务器软件,支持Servlet/JSP的开发规范 Tomcat安装及目录结构安装 官网下载 解压即可 注意:路径不能有中文 配置环境变量 配置JAVA_HOME环境变量 指向JDK 安装目录 目录结构 bin tomcat的执行的文件. conf tomcat的配置文件. lib tomcat运行的需要的jar包. logs tomcat的运行的日志文件. temp tomcat产生临时文件存放的路径. webapps tomcat发布的web项目的路径. work tomcat运行JSP的时候,JSP翻译成Servlet的代码存放的路径. 发布一个WEB工程到Tomcat中 共有三种方式: 1.直接将工程copy到tomcat/webapps下. 将工程复制到webapps即可. 2.配置tomcat虚拟路径-不推荐： 在tomcat/conf/server.xml文件中进行配置: 在标签下配置: &lt;Context path=&quot;/itheima&quot; docBase=&quot;C:/website&quot;/&gt; 3.配置tomcat虚拟路径-推荐： 在tomcat/conf/Catalina/localhost/xxx.xml 配置&lt;Context docBase=&quot;C:/website&quot;/&gt; xxx作为虚拟路径的名称. eclipse开发web项目server配置 选择window下的Perferences弹出窗口 左侧找到Server下的Runtime Enviroment 点击Add按钮 然后选择apchae Tomcat v7.0(也可以是其他版本) 单击Next 填写Tomcat istallation directory 安装目录 然后 Finish]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE加强]]></title>
    <url>%2Fjava%2FJavaSE%E5%8A%A0%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[面向对象封装static 关键字 修饰成员变量和方法 内部类 特点： 随着类的加载而加载 优先于对象存在 被类的所有对象共享 可以被类名调用 优缺点 优点: 对象共享数据，节省空间 被类名直接调用 缺点: 访问有局限性 代码块 在java中，使用{}括起来的代码被称为代码块 分类局部代码块 在方法中出现，控制变量生命周期，及早释放，提高内存利用率 构造代码块 在类中方法外出现，抽取构造方法中的共性，每次创建对象都会执行，并且在构造方法前执行 静态代码块 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。一般用于加载驱动 同步代码块继承 多个类有共同的成员变量和方法，抽取到另一个类中（父类）在让多个类继承父类 格式class 子类 extends 父类 {} 特点 在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类,但多个类可以继承一个父类 在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类 在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类 成员变量 子类只能获取父类的非私有成员super 可以获取父类的成员变量和成员方法，用法与 this 相似 方法重写 当父类方法不能完成满足子类使用用注解 @Override：方法重写，说明下面的方法是重写父类的方法 注意事项： 不能继承父类私有成员 权限修饰符必须大于等于 继承中构造方法的执行顺序A:super(实参列表);语句 在子类的构造方法中使用,用来调用父类中的构造方法(具体哪一个由传递的参数决定),并且只能在构造方法第一行使用 B:this(实参列表); 语句 在类的构造方法中使用,用来调用本类中的其它构造方法(具体哪一个由传递的参数决定),并且只能在构造方法的第一行使用 匿名对象没有变量引用的对象 当方法只调用一次时使用 final关键字final： 修饰符，可以用于修饰类、成员方法和成员变量 final所修饰的类：不能被继承，不能有子类 final所修饰的方法:不能被重写 final所修饰的变量：是不可以修改的，是常量 抽象类abstract 修饰符 用于方法和类 有抽象方法的类必须是抽象类 抽象类的特点： 抽象方法只能在抽象类里面 抽象类和抽象方法必须被abstract修饰 抽象类不能创建对象（不能实例化） 抽象类中可以有非抽象的方法 抽象类和类的关系也是继承 一个类继承了抽象类要么重写所有的抽象方法，要么他自己是抽象类 static 修饰的方法不会被继承 接口处理单一继承的局限性 比抽象类还抽象的类，接口里所有的方法都是抽象方法，接口和类的关系是实现 implements 定义格式public interface 接口名 { 抽象方法1; 抽象方法2; } 使用class 类 implements 接口 { 重写接口中方法 } 抽象类的特点只能有抽象方法 方法只能使用pulic abstract 修饰符 默认使用 可省略 只能有常量 常量只能使用pulic static fianl 修饰符 默认使用 可省略 类与接口关系类与类之间:继承关系,一个类只能直接继承一个父类,但是支持多重继承 类与接口之间:只有实现关系,一个类可以实现多个接口 接口与接口之间:只有继承关系,可以多重继承 优点打破继承的局限性 对外提供规则 降低了程序的耦合性 接口和抽象区别1.共性： 不断的进行抽取，抽取出抽象的，没有具体实现的方法,都不能实例化（不能创建对象） 2.区别与类的关系 类与接口是实现关系，而且是多实现，一个类可以实现多个接口，类与抽象类是继承关系，Java中的继承是单一继承，多层继承，一个类只能继承一个父类，但是可以有爷爷类 成员 a.成员变量 抽象类可以有成员变量，也可以有常量 接口只能有常量，默认修饰符public static final b.成员方法 抽象类可以有抽象方法，也可以有非抽象方法 接口只能有抽象方法，默认修饰符 public abstract c.构造方法 抽象类有构造方法，为子类提供 接口没有构造方法 多态 多态是继封装、继承之后，面向对象的第三大特性 前提 子父类 方法重写 父类引用指向子类对象 动态绑定 运行期方法调用是根据其具体类 优点 可维护性 可扩展性 包多层结构 不同包下文件名可相同 必须在第一行声明 类的全名 包名.类名 使用import 类的全名 将类导入 修饰符 权限修饰符 public protected default private 同一类中 √ √ √ √ 同一包中(子类与无关类) √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 修饰符 类 成员变量 成员方法 构造方法 public Y Y Y Y default Y Y Y Y protected Y Y Y private Y Y Y abstract Y Y static Y Y final Y Y Y 内部类 将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。其他类也称为外部类。 成员内部类在类的成员位置 可以访问外部类的成员包括私有成员 外部类.内部类 对象名 = new 外部类().new 内部类(); 局部内部类 在方法内，出了方法就无法使用 匿名内部类可以看做没有名字的局部内部类 格式 new 类/接口 (){ 有抽象方法就必须实现具体方法体 }; 原理： 创建了这个类（接口）的子类对象 APIObject 类层次结构的根类 方法12toString()equals(Object obj) System 不能被实例化 包含一些有用的字段和方法 方法12345678arraycopy(Object src, int srcPos, Object dest, int destPos, int length)从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。currentTimeMillis() 返回以毫秒为单位的当前时间exit(int status) 终止当前正在运行的 Java 虚拟机 Date 表示特定的瞬间，精确到毫秒 构造函数Date() 创建当前系统时间的Date对象 Date(long date) 创建指定时间的Date对象 方法 setTime(long time) long getTime() 大部分方法已过时 Calendar类代替 DateFormat 抽象类 已知实现子类SimpleDateFormat SimpleDateFormat构造函数SimpleDateFormat() 默认模式创建对象 SimpleDateFormat(String pattern)指定模式创建对象 方法Date parse(String text)解析字符串的文本，生成 Date。 String format(Date date) 将给定的 Date 格式化为日期/时间字符串。 12345678例： SimpleDateFormatsdf = new SimpleDateFormat("yyyy年MM月dd日HH:mm:ss"); Date date = new Date(); String s = sdf.format(date) ----------------- String now = "2000-01-01"； SimpleDateFormatsdf = new SimpleDateFormat("yyyy-MM-dd") Date d2 = sdf.parse(now); Calendar抽象类 已知实现子类GregorianCalendar Calendar c = Calendar.getInstance(); c.get(Calendar.DAY_OF_MONTH ) 包装类由于基本数据类型只能做一些简单的操作和运算，所以java为我们封装了基本类型。 自动装箱和拆箱 从JDK1.5 开始 正则表达式一套规则可以用于比配字符串 Pattern Matcher 字符 x 字符 x \\ 反斜线字符 字符类 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） 预定义字符类 . 任何字符（与行结束符可能匹配也可能不匹配） \d 数字：[0-9] \D 非数字： [^0-9] \s 空白字符：[ \t\n\x0B\f\r] \S 非空白字符：[^\s] \w 单词字符：[a-zA-Z_0-9] \W 非单词字符：[^\w] 数量词 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 集合Collection基本概念接口Collection&lt;E&gt; 层次结构的根1234boolean add(E e)void clear()boolean contains(Object o)boolean isEmpty() 遍历方式1、toArray() 把集合变成数组，然后遍历数组 2、iterator() 迭代器对象，通过迭代器对象迭代集合 Iterator 类 Object next() 下一个元素 boolean hasNext() 判断是否有下一个元素 增强for循环for(元素类型 元素变量：集合或数组对象){ 可以直接使用元素变量 } 在增强for循环中不能修改集合，否则会发生并发异常 并发修改异常在使用迭代器是不允许集合有修改（增加、删除），否则会抛出异常 解决办法 使用迭代器自身去修改集合 ##泛型 是一种广泛的类型，把明确数据类型的工作提前到了编译时期，借鉴了数组的特点 特别注意：泛型只能写引用数据类型。 泛型的好处 避免了类型转换的问题 可以减少黄色警告线 可以简化我们代码的书写 类名上的泛型class Box&lt;E&gt;{} 方法上的泛型public &lt;T&gt; T method(T t){ return t; } 泛型上下限? extends 类名1 泛型上限 ？ super 类名2 泛型下限 常见数据结构数组： 长度一旦定义就不能改变有整数索引只能存储同一种类型的元素即可以存储基本数据类型也可以存储引用数据类型查找快 增删慢 链表 由链子连接起来的一堆节点特点:查询慢 增删快 栈 先进后出 队列 先进先出 List有序 存储顺序有序 索引 允许重复 子类 ArrayList 底层是数组结构 查询快 增删慢 LinkedList 底层是链表结构 查询慢 增删快 方法 addFirst(E e) getFirst() removeFirst() addLast(E e) getLast() removeLast() HashSetList的子类 无序（存储和读取的顺序） 元素唯一 Collections 集合工具类 方法1234567891011int binarySearch(List list,T key) //二分查找指定元素的下标,注意list必须排序完毕copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) // 把源列表数据覆盖到目标列表，注意目标列表的长度至少必须等于源列表fill(List&lt;? super T&gt; list, T obj) //使用指定元素替换指定列表中的所有元素shuffle(List&lt;?&gt; list) //使用默认随机源对指定列表进行置换。sort(List&lt;T&gt; list) //根据元素的自然顺序 对指定列表按升序进行排序。swap(List&lt;?&gt; list, int i, int j) //在指定列表的指定位置处交换元素。 Map 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 与Collextion的区别 Map : 双列集合 通常处理有对应关系的数据 key是不可重复的Collection: 单列集合，有不同子类体系 常用功能 增 put(key ,value) 删 clear() 清除所有remove(Object e) 移除 查 get(Object key) 异常 包含错误的类型、原因、位置 体系结构123graph TDThrowable--&gt;ErrorThrowable--&gt;Exception 处理方式 出现异常未处理 jvm帮我们处理 控制台打印异常信息并终止程序 捕获处理 try ... catch try{ 可能出现问题的代码 }catch(异常类 异常){ } 抛出去 12345678 方法（） throws 异常类 &#123;&#125;新 try(FileWriter fw = new FileWriter("a.txt"))&#123;//自动关流 fw.write(""); &#125;catch(Exception e)&#123; &#125; 异常种类运行时异常 RuntimeException 的子类，在运行时期的异常 编译时异常 Exception子类RuntimeException子类非编译时期必须处理 IO流File类构造方法123File(File parent,String child)File(String path)File(String parent,String child) 方法12345creatNewFile() //创建文件mkdir() //创建文件夹mkdirs()delete() //删除文件，isAbsolute() 路径是否是绝对路径 分类标准输入输出流 System.inSystem.out 转换流 把字节流转换为字符流 outputStreamWriter inputStreamReader 打印流 打印流添加输出数据的功能，使它们能够方便地打印各种数据值表示形式. 字符打印流 PrintWriter void print(String str): 输出任意类型的数据， void println(String str): 输出任意类型的数据，自动写入换行操作 对象流 用于从流中读取对象的 ObjectInputStream称为 反序列化流,利用输入流从文件中读取对象 ObjectOutputStream 称为 序列化流,利用输出流向文件中写入对象 特点：用于操作对象。可以将对象写入到文件中，也可以从文件中读取对象。 多线程概念进程：一个应用程序在内存中执行区域线程：进程中的一个执行控制单元 一个进程可以有多个线程 多线程实现 方式一 继承Thread 类 重写run方法 创建对象 启动 start() 方式二 实现Runnable 接口 网络 设备之间的数据通讯 Socket 三要素ip 网络设备的标识 端口 用于标识进程的逻辑地址 传输协议 udp tcp ip InerAddress表示网络协议（IP) 地址 InetAddress address =InetAddress.getByName(&quot;itheima&quot;);//通过主机名获取InetAddress InetAddress address =InetAddress.getLocalHost();//本地主机InetAddress Udp发送过程1234567891011121314 //创建Socket对象 DatagramSocket ds =new DategramSocket();//创建socket对象随机分配端口 //DatagramSocket ds =new DategramSocket(1000);指定端口 //创建数据并打包 //DatagramPacket 数据包类 byte[] bys;//数据 InetAddress addr = InetAddress.getByName("");//ip地址 int port ;//端口 DatagramPacket dp = new DatagramPacket(bys,bys.length,addr,port);// 发送数据 ds.send(dp); //关闭资源 ds.close(); 接收过程1234567891011121314 //创建Socket对象 DatagramSocket ds =new DategramSocket(1000);//指定端口//接收数据byte[] bys = new byte[1024];DatagramPacket dp = new DatagrmPacket(bys,bys.length);ds.receive(dp);//拆分数据InetAddress addr =dp.getAddress();int length =dp.getLength();//数据长度//byte[] data =dp.getData();//数据会在bys 中//关闭资源ds.close(); Tcp发送123456789 //创建socket对象 Socket socket = new Socket(InetAddres.getByName(""),10086);// 获取输出流对象OutputSteam os socket.getOutputStream();// 发送数据 os.write(""); //关闭资源 socket.close(); 接收12345678910 ServerSocket ss = new ServerSocket(10086); //监听Socket socket = ss.accept();//获得输入流InputStream is =socket.getInputStream();byte[] bs = new byte[1024];int len =is.read(bs);is.close(); 反射 运行过程中获取对象，对象中的成员 获取字节码对象Class clz =Class.forName(&quot;类的全名&quot;); 获取构造方法Constructor[] cs= clz.getConstructors() //获取所有public 构造方法 Constructor c =clz.getConstructor();//获取无参构造 Constructor c =clz.getConstructor(T.class,..);//获取有参构造 创建对象Object o = c.newInstance();//无参 c为无构造 Object o = c.newInstance(...);//有参 传递实参 c为有参构造 获取成员字段Field field =clz.getField(); Field[] getFields(); public 字段 getDeclarefields(); 所有的字段 field.get(o) //获取o对象上的field字段的值 field.setAccessible(true) //设置反射取消java访问检查 field.set(o,值) //给o对象上的field字段设值 获取成员方法Method m = clz.getMethod(&quot;method&quot;,形参类型); m.Invoke(o,实参); 调用方法 内省技术 内省是基于反射,获取类中的属性和get/set方法 BeanUtil.populate()使用到内省技术 JavaBean 满足了特定格式的java类 无参构造 属性私有化,并提供set/get方法 Introspector Introspector.getBeanInfo() BeanInfo类 PropertyDescriptor[] psds= beanIfo.getPropertyDesciptors(); PropertyDescriptor类pd.getName() Method m= pd.getReadMethod() //getxx()方法 pd.getWriteMethod() //setxx()方法]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>进阶学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础]]></title>
    <url>%2Fjava%2FJavaSE%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JavaSE基础环境搭建安装JDK配置环境变量JVM JRE =JVM +类库 JDK =JRE+java开发工具 数据类型基本数据类型 整数 byte 一个字节 short 两个字节 int 四个字节 long 八个字节 小数 float 4个字节 double 8个字节 字符 char 2个字节 布尔 boolean float double 在内存中存放结构float一共32位，其结构定义如下：|—— 31 —–|—- 30-23 —— |—— 22-0 —–|符号位(sign) 指数部分(exp) 小数部分(mag) sign:符号位就一位，0表示正数，1表示负数 exp: 指数部分，无符号正数 mag:小数部分，定点小数，小数点在最左边 float的表达式 : pow(-1,sign) * (1+mag) * pow(2,exp-127) 引用数据类型数组 对象(new出来的) 需要注意的 1234byte a=10,b=20;byte c=a+b;//编译通不过，byte short char 做+、-、*、/运算时结果为int类型byte b = 3;//java有常量优化机制 , 3 为常量 在取值范围内jvm会自动强制转换 常量、变量 变量定义格式 数据类型 变量名 = 初始化值； 例： int a=10; 算数运算+ - * / % ++ -- 逻辑运算&amp; | ！ ^ &amp;&amp; || 三元运算符关系表达式？表达式1：表达式2； int c=a&gt;b?a:b; 不能单独存在,结果必须被接收 条件语句12345678if(条件)&#123;&#125;switch()&#123; case 值: break; default: break;&#125; 循环语句123456for(;;)&#123;&#125;while()&#123;&#125;do&#123;&#125;while(); 跳转语句 breakcontinuereturn 数组声明数组：数据类型[] 数组名； 数组赋值： 数组名=new 数组类型[数组长度]； 数组名=new 数组类型[]{数据1，数据2，…}； 数组进行初始化 a:动态初始化 只指定长度，由系统给出初始化值 int[] arr = new int[5]; b:静态初始化 给出初始化值，由系统决定长度 int[] arr = new int[]{1,2,3,4,5}; 简写：int[] arr = {1,2,3,4,5}; c 不能动静结合的初始化 如int[] arr = new int[5]{1,2,3,4,5};编译不会通过 1234//例子：int[] arr =new int[5];//动态初始化int arr =new int[]&#123;1,2,3,4,5&#125;;//静态初始化int arr =new int[5]&#123;1,2,3,4,5&#125;; //错误的表示编译报错 二维、多维数组 int[][] arr=new int[m][n]; 排序 冒泡排序 123456789for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j+1 &lt; arr.length-i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; int temp =arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125;&#125; 选择排序 123456789for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i+1; j &lt; arr.length; j++) &#123; if (arr[i] &gt; arr[j]) &#123; int temp =arr[i]; arr[i] =arr[j]; arr[j] = temp; &#125; &#125;&#125; 方法（函数）定义： 声明：大括号前面的内容 内容：大括号里面的内容 修饰符 返回类型 方法名（参数类型 参数1，参数类型 参数2....）{ //return ;//当返回类型为void 是可以省略，可以不带值 return 返回值；//返回值的类型必须与返回类型匹配 } 面向对象 面向过程: 一步一步的执行 强调过程 面向对象: 是一种思想基于面向过程的 将过程封装起来是一种更符合我们思考习惯的思想复杂变简单执行者变成指挥者 Java语言最基本的单位-类 类：是一组相关的属性和行为的集合 对象：就是该事物的具体体现 三大特性 封装 将不需要对外提供的内容都隐藏起来 继承 多态 构造方法 与类名一致 不写返回值类型 1234class Person&#123; public Person()&#123;//构造方法 &#125;&#125; javaBean规范 空参构造属性私有化提供setXXX(…) getXXX() API 应用程序接口 String类构造方法123String(String original)String(char[] value)String(char[],int index,int count)//把字符数组的一部分变成字符串对象 字符串的内容存储在方法区的常量池中的，方便字符串的重复使用 常用方法1234boolean equals(Object obj):比较字符串的内容是否相同boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写boolean startsWith(String str):判断字符串对象是否以指定的str开头boolean endsWith(String str):判断字符串对象是否以指定的str结尾 StringBulider类IO流 可以把数据存储到文件也可以从文件中读取数据 分类 按方向： 输入流 输出流 按功能： 节点流 处理流 按数据 字节流 字符流 FileWriter 类构造方法123FileWriter(File file)FileWriter(String fileName)FileWriter(String fileName,boolean flag) //flag表示是否在文件末尾追加写入 默认false 常用方法123456write(String str) //写字符串wirte(String str,int index,int len)write(char ch)wirte(char ch,int index,int len)flush() //刷新close() //关闭流释放资源，流将不能再使用了 使用步骤 创建对象，关联文件 调用输出流对象的写数据方法write(String str) 关闭资源 1234//例子：FileWrite fw =new FileWriter("D:\\a.txt");fw.write("IO流");fw.close(); 换行符window : \r\n linux :\n max :\r FileReader类构造方法12FileReader(Flie flie)FileReader(String fileName) 常用方法12int read();close(); 使用步骤 创建输入流对象 调用输人流对象的读数据方法read() 关闭释放资源 1234例子：FileReader fr =new FileReader ("D:\\a.txt");int a = fr.read();fr.close(); BufferedWriter 类 高效的写字符输出流构造方法1BufferedWriter(FileWriter fileWriter) 常用方法1234write(String s)flush();close()newLine(); //写一个换行符 123456//例子BufferedWriter bw = new BufferedWriter(new FileWriter("a.txt"));bw.wirte("abv")bw.flush();bw.close(); BufferedReader类 高效的文本读取构造方法1BufferedReader(FileReader fr) 常用方法1234read()flush();close()readLine() 一次读一行字符不包括换行符 12345//例子BufferedReader br = new BufferedReader(new FileReader("a.txt"));int c = bw.read()bw.flush();bw.close();]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法]]></title>
    <url>%2FMarkdown%2FMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 强调星号与下划线都可以，单是斜体，双是粗体，符号可跨行，符号可加空格 **一个人来到田纳西** __毫无疑问__ *我做的馅饼 是全天下* _最好吃的_ 斜体和粗体代码： *斜体*或_斜体_ **粗体** ***加粗斜体*** ~~删除线~~ 分割线三个或更多-_*，必须单独一行，可含空格 --- *** ___]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xml]]></title>
    <url>%2FJavaWeb%2Fxml%2F</url>
    <content type="text"><![CDATA[什么是xml可扩展标记语言 功能传输和存储数据 软件的配置文件 使用xml语法基本语法:- XML必须有关闭标签 - 区分大小写 - 属性需要有引号 - 标签必须正确嵌套. 文档声明 注释 元素 属性 特殊字符和CDATA区 文档声明通常出现在xml 文档的第一行第一列12345&lt;?xml 属性名=&quot;值&quot; ... ?&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;* version :必须的. 使用”1.0”* encoding :字符集. 是使用浏览器打开的时候采用的默认的字符集的编码.* standalone :描述XML文档是否需要依赖其他的文件. 注释&lt;!-- 注释内容 --&gt; 元素(标签)命名规范 字母 数字 及其他字符 不能以数字或标点符号开始 不能以字符”xml”(“XML/Xml”)开始 不能包含空格 属性属性的名称规范与元素一致 需要引号 特殊字符和CDATA区#####特殊字符 &amp;lt; &lt; 小于 &amp;gt; &gt; 大于 &amp;amp; &amp; 和号 &amp;apos; &apos; 单引号 &amp;quot; &quot; 引号 CDATA区CDATA区中的所有内容都会被认为是字符串1&lt;![CDATA[ 内容 ]]&gt; xml解析从xml文档中获取数据 解析方式 DOM解析 Doucument Object Model SAX解析 Simple Api for Xml 两种解析方式的区别DOM: 一次性将文档加载到内存形成树形结构解析 优点:当文件特别大时容易内存溢出 缺点:对xml进行增删改操作 SAX: 事件驱动方式,一行一行的解析 优点:不能对文档进行增删改操作 缺点:当文件特别大时不会内存溢出 api实现与案例针对这两种解析的方式，不同的公司提供了不同的API的实现. JAXP :SUN公司提供的一套XML的解析的API. JDOM :开源组织提供了一套XML的解析的API-jdom. DOM4J :开源组织提供了一套XML的解析的API-dom4j. pull :主要应用在Android手机端解析XML. dom4j案例代码 【步骤一】导入jar包.dom4j-1.6.1.jar 【步骤二】创建解析器 【步骤三】解析文档获得代表文档的Document对象. 【步骤四】获得跟节点. 【步骤五】从跟节点下查找其他的节点 12345678910111213141516// 创建解析器SAXReader reader = new SAXReader();// 解析XML的文档Document document = reader.read("xml/demo1.xml");// 获得跟节点Element root = document.getRootElement();System.out.println(root.getName());// 查找跟节点下的子节点. element() elements();Element pElement = root.element("person"); // 查找的是第一个person元素// root.elements("person").get(1); // 查找的是第二个person元素Element nElement = pElement.element("name");Element aElement = pElement.element("age");Element sElement = pElement.element("sex");System.out.println(nElement.getText());System.out.println(aElement.getText());System.out.println(sElement.getText()); XPathXPath由W3C的XPath 1.0 标准描述,dom4j支持xpath jaxen-1.1-beta-6.jar dom4j的XPath支持的API: List document.selectNodes(String xPath); Node document.selectSingleNode(String xPath);1234567891011121314// 创建解析器: SAXReader reader = new SAXReader(); // 解析XML返回Document对象. Document document = reader.read("xml/demo1.xml"); /*List&lt;Node&gt; list = document.selectNodes("//name"); for (Node node : list) &#123; Element element = (Element) node; System.out.println(element.getText()); &#125;*/ List&lt;Node&gt; list = document.selectNodes("//person['@id']"); for (Node node : list) &#123; Element element = (Element) node; System.out.println(element.attributeValue("id")); &#125; xml约束XML的约束的概述: 什么是XML的约束 :就是用来约束XML的文档中可以出现哪些标签，不能出现哪些标签，标签中是否有顺序，出现的次数. XML的约束 :用来规范XML的写法 ###XML的约束的种类及区别?DTD 和 Schema : 区别: 1.DTD语法是自成一体的.Schema语法就是XML的语法. 2.Schema的语法就是XML的语法所以更容易被解析器所解析. 3.Schema支持名称空间. 4.Schema有比DTD更加强大的语义和语法的约束. DTD的语法####DTD的引入方式: 内部的DTD:&lt;!DOCTYPE persons []&gt; 外部的DTD: 一种本地DTD:&lt;!DOCTYPE persons SYSTEM “unknown.dtd”&gt; 一种网络DTD:&lt;!DOCTYPE persons PUBLIC “//UNKNOWN/“ “unknown.dtd”&gt; 元素: &lt;!ELEMENT 元素名 元素类型&gt; 元素类型: EMPTY ANY 子元素 是否有序: 使用 逗号(,)或者竖线(|)表示. 出现的次数：?:零次或一次 +：一次或多次 *：零次或多次 PCDATA 可解析的字符串 属性: &lt;!ATTLIST 元素名称 属性名称 属性的类型 属性的约束&gt; 属性的类型: ID类型:表示属性值需要是唯一的. CDATA类型:普通的字符串. 枚举: 属性的约束: #REQUIRED 属性值是必须的 #IMPLIED 属性不是必须的 #FIXED value 属性值固定12345678&lt;!ELEMENT persons (person*)&gt;&lt;!ELEMENT person (name|age|sex)*&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT age (#PCDATA)&gt;&lt;!ELEMENT sex (#PCDATA)&gt;&lt;!ATTLIST person id ID #REQUIRED&gt; Schema的语法12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 名称空间:一个XML只能引入一个DTD约束文档.使用了Schema约束XML文档,一个XML可以引入多个Schame的约束!!! 如果再多个Schema文档中定义了相同的属性名称 该怎么办? * 名称空间类似于java中的package.通过名称空间区分 标签或属性来自于哪个文档的！！！通常名称空间唯一的不重复的即可.一般情况下使用一个URL地址表示一个名称空间. xmlns :xml name sapace .代表当前的文档应用的名称空间. targetNameSpace :目标名称空间. elementFormDefault : --&gt;&lt;schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.itheima.com/ee25" elementFormDefault="qualified"&gt; &lt;!-- 复杂标签 --&gt; &lt;element name="persons"&gt; &lt;!-- 复杂类型 --&gt; &lt;complexType&gt; &lt;sequence maxOccurs="unbounded" minOccurs="1"&gt; &lt;element name="person"&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;!-- 简单标签 --&gt; &lt;element name="name" type="string"&gt;&lt;/element&gt; &lt;element name="age" type="int"&gt;&lt;/element&gt; &lt;element name="sex" type="string"&gt;&lt;/element&gt; &lt;/sequence&gt; &lt;attribute name="id" type="string" use="required"/&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt;&lt;/schema&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站主题设置]]></title>
    <url>%2F%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%2F%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[动态背景 修改 _layout.swig 主题文件下/layout/_layout.swig 在 &lt;\/body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面) 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 修改主题配置文件 打开 主题下的_config.yml,在里面添加如下代码：(可以放在最后面)123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 主页文章阴影效果打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 在网站底部加上访问量编辑 主题配置文件 中的busuanzi_count的配置项。 当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。 \themes\next\layout_partials\footer.swig文件,在copyright前加上画红线这句话：1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后添加显示统计的代码123456&lt;!-- 放在&lt;div class=&quot;powered-by&quot;&gt; 前--&gt;&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 首页只显示文章部分 修改 _config.yml文件123auto_excerpt: enable: true length: 150 页脚元素居中修改your blog\themes\next\source\css\schemes\Mist\index.styl文件，将.footer-inner中的text-align: left;修改为text-align: center;即可。 修改文章内链接文本样式修改文件 themes\next\source\css\_common\components\post\post.styl ，在末尾添加如下css样式，： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; blog文章书写开头格式1234567891011title: # 文章标题author: # 作者tags: - Hexo - Nextcategories: - Hexo - Nextdescription: # 描述，首页文章显示的摘要date: --- 关闭侧边栏设置在\source\js\src\motion.js里自行写实现该效果的js方法（当然也可以放在页面其他js文件里面）： 这里贴一个实现此需求的js方法： // $(‘.sidebar-inner’).css({‘height’:’100%’});$(‘body’).on(‘click’,function(e){ var bSidebarShow = $(‘#sidebar’).css(‘display’)===’block’ &amp;&amp; $(‘#sidebar’).width() &gt; 0; var bFlag = $(e.target).parents(‘#sidebar,.sidebar-toggle’).length &gt; 0; if(bSidebarShow &amp;&amp; !bFlag){ $(‘.sidebar-toggle-line-wrap’).trigger(‘click’); e.preventDefault(); }}); 侧边栏居左 修改 source\js\src\motion.js使用Ctrl+F查找paddingRight 把其修改为paddingLeft就可以了 source\css_custom下为custom.styl添加内容123456 .sidebar-toggle&#123; left:30px;&#125;.sidebar&#123; left:0;&#125; 把back-to-top这个按钮留在了右侧如果你偏向一并放在左侧 添加以下css123.back-to-top&#123; left:30px;&#125; 修改箭头动画方向修改motion.js文件123456789101112131415161718192021var sidebarToggleLine1st = new SidebarToggleLine(&#123; el: '.sidebar-toggle-line-first', status: &#123; arrow: &#123;width: '60%', rotateZ: '45deg', top: '2px', left: '50%'&#125;, close: &#123;width: '100%', rotateZ: '-45deg', top: '5px'&#125; &#125;&#125;);var sidebarToggleLine2nd = new SidebarToggleLine(&#123; el: '.sidebar-toggle-line-middle', status: &#123; arrow: &#123;width: '90%'&#125;, close: &#123;opacity: 0&#125; &#125;&#125;);var sidebarToggleLine3rd = new SidebarToggleLine(&#123; el: '.sidebar-toggle-line-last', status: &#123; arrow: &#123;width: '60%', rotateZ: '-45deg', top: '-2px', left: '50%'&#125;, close: &#123;width: '100%', rotateZ: '45deg', top: '-5px'&#125; &#125;&#125;); 不能调整透明就把motion.js中选择的两个body改成了.containerNexT.utils.isDesktop() &amp;&amp; $(‘.container’).velocity(‘stop’) 侧栏背景图以及内部文字颜色的修改在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：1234567#sidebar &#123; background:url(图片链接); background-size: cover; background-position:center; background-repeat:no-repeat; p,span,a &#123;color: 颜色代码;&#125;&#125; 滑动的menumenu中的搜索LocalSearch搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： $ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： Local search local_search: enable: true]]></content>
      <categories>
        <category>网站搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog网站搭建]]></title>
    <url>%2F%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%2F%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[准备 Node.js Git Hexo github账号 安装node.js官网 安装Git直接到Git官网 下载安装即可 安装Hexo 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装好Node.js与Git 执行命令 1npm install -g hexo-cli 初始化随便建一个文件夹，名字随便取，博主取其名为blog，cd 到文件夹里，先安装必要的文件，执行以下命令：12hexo init # hexo会在目标文件夹建立网站所需要的所有文件npm install # 安装依赖包 本地启动有了必要的各种配置文件之后就可以在本地预览效果了12hexo g # 等同于hexo generate，生成静态文件hexo s # 等同于hexo server，在本地服务器运行 打开浏览器并输入IP地址 http://localhost:4000/ 查看 简单的命令总结一下简单的使用命令1234567hexo init [folder] # 初始化一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站hexo new [layout] &lt;title&gt; # 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来hexo version # 查看版本hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g # 等于hexo generate # 生成静态文件hexo s # 等于hexo server # 本地预览hexo d # 等于hexo deploy # 部署，可与hexo g合并为 hexo d -g 安装主题git克隆Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可使用git克隆最新版next主题12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题打开站点配置文件， 找到 theme 字段，并将其值更改为 next1theme: next 然后 hexo s 即可预览主题效果 更换主题外观NexT有三个外观，博主用的是 Muse，直接更改主题配置文件的 scheme 参数即可，如果显示的是繁体中文，那么站点配置文件中的 language: zh-CN123scheme: Muse#scheme: Mist#scheme: Pisces 注册Github部署到Github与Coding在此之前，先安装Git部署插件1npm install hexo-deployer-git --save 打开站点配置文件，拉到底部，修改部署配置：1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:masteranthoneyd/masteranthoneyd.github.io.git,master coding: git@git.coding.net:ookamiantd/ookamiantd.git,master 终端执行123hexo cleanhexo ghexo d 绑定域名]]></content>
      <categories>
        <category>网站搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
