<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jsp&EL&JSTL]]></title>
    <url>%2FJavaWeb%2FJavaWeb-jsp%26El%26JSTL%2F</url>
    <content type="text"><![CDATA[jsp&amp;EL&amp;JSTLjspJsp概述 Jsp(Java server Pages,Java服务器端页面)，动态网页技术 Jsp运行过程：转换成一个servlet类，编译之后才能运行 JSP嵌入Java代码:JSP的脚本元素 &lt;%! %&gt;:翻译成类中的成员部分. 定义变量,定义方法,定义类.Servlet是线程不安全的,尽量少在类中定义成员属性！！ &lt;% %&gt;:翻译成类的service方法内部的内容. 定义变量,定义类,直接写代码块. &lt;%= %&gt;:翻译成service方法内部的out.print(); JSP的注释JSP的注释: &lt;%-- JSP的注释 --%&gt;HTML注释：只能注释HTML标签 12345&lt;!-- &lt;c:for start=”1” end =”10” &gt; &lt;h1&gt;aaaaa&lt;/h1&gt; &lt;/c:for&gt;--&gt; java注释 只能注释java代码 JSP中有三个指令 JSP中有三个指令:page指令, include指令, taglib指令. JSP的page指令 contentType: 设置浏览器打开这个JSP的时候采用的默认的字符集的编码. pageEncoding: 设置文件保存到本地硬盘,以及生成Servlet后,Servlet保存到硬盘上的编码. import: 在JSP中引入类对象.但是import可以出现多次. 1&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; JSP的include指令: 指示JSP包含其他的页面 1234&lt;%@ include file="logo.jsp" %&gt;&lt;%@ include file="menu.jsp" %&gt;&lt;h1&gt;BODY部分&lt;/h1&gt;&lt;%@ include file="footer.jsp" %&gt; JSP中的taglib指令:指示JSP引入标签库. 1`&lt;%@ taglib uri="标签的URI的路径" prefix="标签的别名" %&gt;` JSP中有9大内置对象 request response session application ServletContext page 当前页面 pageContext config out JspWriter exception JSP的四个域范围 PageScope: 当前页面中有效. pageContext---------&gt; PageContext RequestScope: 一次请求范围. request---------&gt; HttpServletRequest SessionScope: 一次会话范围. session---------&gt; HttpSession ApplicationScope: 整个应用范围 application---------&gt; ServletContext EL 表达式语言 EL的概述:Excepress Language,表达式语言 作用：以最简单的方式操作JSP 使用EL表达式语法:${ EL表达式 } 概括: EL 是从 JavaScript 脚本语言得到启发的一种表达式语言，它借鉴了 JavaScript 多类型转换无关性的特点。在使用 EL 从 scope 中得到参数时可以自动转换类型，因此对于类型的限制更加宽松。 Web 服务器对于 request 请求参数通常会以 String 类型来发送，在得到时使用的 Java 语言脚本就应该是request.getParameter(“XXX”) ，这样的话，对于实际应用还必须进行强制类型转换。而 EL 就将用户从这种类型转换的繁琐工作脱离出来，允许用户直接使用EL 表达式取得的值，而不用关心它是什么类型 获取数据:(JSP的四个域)获取域对象 `${ applicationScope.name }` 访问数组元素 `${ arrs[下标] }` 访问集合 `${ list[下标] }` `${ map.key的值 }` 获取对象的属性 `${ user.id }` 获取对象的集合的数据 `${ userList[0].id }` ==`.`和`[]`的区别== `[]`用于有下标的数据(数组,list集合) `.`用于有属性的数据(map,对象) 如果属性名中包含有特殊的字符.必须使用`[]` 如果EL表达式从四个域对象中没有取到值会返回`&quot;&quot;`, 而不是`null`, 但属性名写错会报错，如 `${user.naaa}` 在书写表达式时，如果没有指定搜索范围，那么系统会依次调用`pageContext`、`request`、`session`、`application`的`getAttribute()`方法。这样不限定查找范围的代码不利于排错，所以这种取值的操作可以先定对象的查找范围。如：`${sessionScope.user.name}` 一旦指定了对象所在的范围，那么只会在范围内查找绑定对象，不会在找不到的时候再去其他区域中查找了。 运算: EL执行算数运算 ${ n1 + n2 } EL执行比较运算 ${ n1 eq n2 } EL执行关系运算 and or not EL执行三元运算 ${ n1 &lt; n2 ? &quot;正确&quot;:&quot;错误&quot; } 判断null ${ empty user }`${ not empty user }`空运算主要用于判断字符串，集合是否为空，是空或为null及找不到值时都会输出true 操作WEB开发的常用的对象`pageScope,requestScope,sessionScope,applicationScope` - 获取JSP中域中的数据 `param,paramValues` - 接收参数. `header,headerValues` - 获取请求头信息 `initParam` - 获取全局初始化参数 `cookie` - WEB开发中cookie `pageContext` - WEB开发中的pageContext. ${ param.id }===request.getPamameter(“id&quot;) 获取Cookie中的值${ cookie.history.value } 调用API：${ pageContext.request.remoteAddr } ${ pageContext.request.contextPath } JSTL 概述JSTL概述：Jsp Standard Tag library,Sun 公司 Java 规范标准的 JSTL 由 apache组织负责维护。作为开源的标准技术，它一直在不断地完善。JSTL 的发布包有两个版本： Standard-1.0 Taglib 、 Standard-1.1 Taglib ，它们在使用时是不同的。 使用JSTL 引入JSTL的相关的jar包. 在页面中引入标签库.&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; 基本语法 12345678910111213 &lt;c:if test="$&#123;&#125;"&gt; .... &lt;/c:if&gt;&lt;% User user = new User(); user.setName("胡萝卜"); user.setGender("f"); request.setAttribute("user",user);%&gt;姓名:$&#123;user.name&#125;&lt;br/&gt;性别:&lt;c:if test="$&#123;user.gender =='m'&#125;" var="rs" scope="request"&gt;男&lt;/c:if&gt;&lt;c:if test="$&#123;!rs&#125;"&gt;女&lt;/c:if&gt; JSTL的forEach标签 加强For: var=&quot;i&quot; items = “{被遍历的对象}&quot; 普通for: var =&quot;i&quot; begin=&quot;开始数据&quot; end=&quot;结束数据&quot; step=&quot;步数&quot; varstatus=&quot;&quot; 统计循环的个数 举例:其中items属性为要遍历的集合，var属性为每次取出来的一个对象，varStatus指定当前迭代的状态 1234567891011121314&lt;table&gt; &lt;tr&gt; &lt;td&gt;序号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;users&#125;" var="u" varStatus="s"&gt; &lt;tr&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;u.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;u.age&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaweb会话技术]]></title>
    <url>%2FJavaWeb%2FJavaWeb-Cookie%26Session%2F</url>
    <content type="text"><![CDATA[会话技术 会话: 用户打开一个浏览器访问页面,访问网站的很多页面,访问完成后将浏览器关闭的过程称为是一次会话. 常见的会话技术: Cookie :将数据保存到客户端浏览器. Session :将数据保存到服务器端. URL重写 隐藏表单域 hidden Cookie 向浏览器保存数据: HttpServletResponse有一个方法:void addCookie(Cookie cookie);获得浏览器带过来的Cookie:HttpServletRequest有一个方法:Cookie[] getCookies();创建一个Cookie对象:Cookie(String name,String value); Cookie常用API getName(); –获取Cookie的名称 getValue(); –获取Cookie的值 setDomain(String domain); – 设置Cookie的有效域名. setPath(String path); – 设置Cookie的有效路径. setMaxAge(int maxAge); – 设置Cookie的有效时间. setMaxAge如果咱们不手动设置值它的默认值是-1,即为临时Cookie 如果想删除一个cookie的话就给它设置为0 如果给它设置为一个正数值,代表就是它的存活时间 60 * 60 * 24 * 7 如果是相同path和相同domain下相同的cookie name会覆盖 Cookie的分类 会话级别的Cookie:默认的Cookie.关闭浏览器Cookie就会销毁. 持久级别的Cookie:可以设置Cookie的有效时间.那么关闭浏览器Cookie还会存在. 手动销毁持久性Cookie.setMaxAge(0)(前提是有效路径必须一致) 示例:显示商品浏览记录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class ProductServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 接收id: String id = request.getParameter("id"); // 获得所有的Cookie的信息: Cookie[] cookies = request.getCookies(); // 判断是否是第一次: Cookie cookie = CookieUtils.findCookie(cookies, "history"); if(cookie == null)&#123; // 第一次浏览商品 Cookie c = new Cookie("history",id); c.setPath("/xxx"); c.setMaxAge(60*60*24*7); response.addCookie(c); &#125;else&#123; // 不是第一次浏览 // 判断选择的商品是否已经在浏览记录中 2-1 String value = cookie.getValue(); String[] ids = value.split("-"); // 将数组变为集合： LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;(Arrays.asList(ids)); if(list.contains(id))&#123; // 之前浏览过该商品 list.remove(id); // 1-2-3 list.addFirst(id); &#125;else&#123; // 没有浏览过该商品. if(list.size() &gt;=3 )&#123; // 超过3个 list.removeLast(); list.addFirst(id); &#125;else&#123; // 没到3个. list.addFirst(id); &#125; &#125; // 将list中的元素取出,使用-连接上保存到Cookie,写回浏览器. StringBuffer sb = new StringBuffer(); for(String s:list)&#123; sb.append(s).append("-"); &#125; String sValue = sb.toString().substring(0,sb.length()-1); System.out.println(sValue); // 存入到Cookie中 Cookie c = new Cookie("history",sValue); c.setPath("/xxx"); c.setMaxAge(60*60*24*7); response.addCookie(c); &#125; request.getRequestDispatcher("/xxx/product_info.htm").forward(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; Session 基于Cookie的JSESSIONID 获得Session:request.getSession();/request.getSession(boolean) Cookie与Session的区别Cookie本身是有大小和个数的限制.大小一般不超过4KB, 个数的不超过20个,Session没有限制.Cookie的数据保存在客户端,Session数据保存在服务器端.Cookie被禁止了，默认session也不能使用 存储位置Cookie存储在浏览器客户端 Session存储在服务器内存中 Cookie有大小限制 Session是没有大小限制 Cookie只能存储String Session可以存储object 获取Cookie newCookie(String String) 获取Session req.getSession() Session是域对象 Cookie不是域对象 Session是依赖于Cookie session作为域对象存取数据session的创建和销毁 创建: 服务器端第一次调用getSession()创建session.，以后调用getSession获得同一个 销毁:三种情况销毁session: session过期. 默认过期时间为30分钟. 在Tomcat设置：所有的项目的session 在某个项目中的web.xml设置：当前工程的所有session给某个session对象设置：对应的session对象setMaxInactiveInterval(int interval) 非正常关闭服务器.如果正常关闭session序列化到硬盘. 手动调用session.invalidate(); 作用范围:多次请求.(一次会话) ==Servlet中的域对象：request,session,ServletContext== request:范围一次请求，转发时能够共享数据,一个请求对应一个 session:一次会话（包含多次请求与响应），转发与重定向都能共享,一个用户对应一个 ServletContext:一个项目都有效，包含多个会话 共同的特点：存储数据 `setAttribute()/getAttribute()/removeAttribute()` `Cookie, new Cookie(String,String)` `session, setAttribute(String,Object)` Session总结作用：域对象存储数据 `setAttribute()/getAttribute()` 创建：在第一次访问`(request.getSession())session` 销毁：三种方式 设置session生存时间，默认在tomcat中有配置 web.xml: 1234567&lt;session-config&gt; &lt;session-timeout&gt;30min&lt;/session-timeout&gt;&lt;/session-config&gt;配置当前工程web.xml：&lt;session-config&gt; &lt;session-timeout&gt;60&lt;/session-timeout&gt;&lt;/session-config&gt; 配置单个session：`setMaxInActiveInterval(s)` 范围：session：一次会话有效（多次请求响应）]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet 二]]></title>
    <url>%2FJavaWeb%2FJavaWeb-Servlet%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[#Servlet 一 读取WEB工程下的文件1234// 传统方式,不适用web工程InputStream is = new FileInputStream("src/db.properties");Properties properties = new Properties();properties.load(is); 1234567891011121314151617// 使用类的加载器来读取文件.// 类的加载器用来加载class文件,将class文件加载到内存.InputStream is = ReadFileUtils.class.getClassLoader().getResourceAsStream("db.properties");Properties properties = new Properties();properties.load(is);//web方式`ServletContext. getResourceAsStream("/WEB-INF/classes/db.properties");`通过相对路径获得绝对路径`String realPath = context.getRealPath("/WEB-INF/classes/db.properties");`// 获得该文件的磁盘绝对路径.`InputStream is = new FileInputStream(realPath);` ServletContext功能概述 读取全局初始化参数 ServletContext.getInitParameter() 读取web.xml中的参数 ServletConfig.getInitParameter() 读取servlet标签中配置的参数 获得文件的MIME的类型 MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开文件下载，设置mime类型，浏览器自动使用指定应用程序来打开 ServletContext.getMimeType(“xxxxx.jpg”); 作为域对象存取数据setAttribute(key,Object)/getAttribute(key) ServletContext对象 创建时间：服务器启动的时候创建，一个项目有且仅有一个ServletContext对象 销毁时间：服务器关闭或者项目移除 读取web项目下的文件 默认读取项目根路径下的文件ServletContext.getResourceAsStream(“路径”) 通过相对路径动态获得根盘符的绝对路径ServletContext.getRealPath(“路径”) 文件下载功能输出中文字符：`response.setContentType(“text/html;charset=UTF-8”);` 字符流: `response.getWriter()` 字节流：`response.getOutputStream()` (做文件下载) 1234567891011// 2.1设置Content-Type头String type = this.getServletContext().getMimeType(filename);response.setHeader("Content-Type", type);// 2.2设置Content-Disposition头response.setHeader("Content-Disposition","attachment;filename="+filename);// 2.3设置文件的InputStream.//realPath = this.getServletContext().getRealPath("/download/"+filename);//InputStream is = new FileInputStream(realPath);InputStream is = this.getServletContext.getResourceAsStream("/download/"+filename)// 获得response的输出流:OutputStream os = response.getOutputStream(); Request对象 Request对象的功能 1.获得客户端的信息 `String getRequestURI()` `StringBuffer getRequestURL()` 2.获得请求参数 `getParameter(key)` 3.域对象，存储数据 `setAttribute(key,Object)` `getAttribute()` 4.转发 `request.getRequestDispatcher(&quot;/demo1-download/login.jsp&quot;).forward(request, response);` response对象 重定向response.sendRedirect(路径) 输出字符串response.getWriter().println(字符串) 设置各种响应头的信息response.setContentType(“text/html;charset=utf-8”)下载设置文件的显示方式 response.setHeader(“Content-disposition”,”attachement;filename=xxx.xx”) ##转发与重定向的区别 重定向的地址栏会发生变化,转发的地址栏不变 重定向两次请求两次响应,转发一次请求一次响应. 重定向路径需要加工程名,转发的路径不需要加工程名. 重定向可以跳转到任意网站,转发只能在服务器内部进行转发. 重定向不能使用request域存储数据，转发可以使用request存储数据 中文乱码的解决接收中文乱码 get方式 `new String(String.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);` post方式 `request.setCharacterEncoding(“UTF-8”)` 输出中文乱码 字符流 设置`response.setContentType(&quot;text/html;charset=UTF-8&quot;);` 字节流 `response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);` // 设置浏览器默认打开的时候采用的字符集编码 `response.getOutputStream().write(&quot;中文&quot;.getBytes(&quot;UTF-8&quot;));` // 设置中文转成字节数组的时候取出的编码]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet 一]]></title>
    <url>%2FJavaWeb%2FJavaWeb-Servlet%2F</url>
    <content type="text"><![CDATA[#Servlet 一 主要点 servlet的生命周期 url-pattern的配置 路径问题 ServletContext对象 Servlet 实现类 Servlet :接口 GenericServlet :通用的Servlet HttpServlet :处理http协议的Servlet Servlet的生命周期 对象从创建到销毁的过程 Servlet生命周期: Servlet从创建到销毁的过程. 何时创建:用户第一次访问Servlet创建Servlet的实例, 只会被创建一次, 所以是单例何时销毁:当项目从服务器中移除的时候，或者关闭服务器的时候. ==用户第一次访问Servlet的时候,服务器会创建一个Servlet的实例,那么Servlet中init方法就会执行.任何一次请求服务器都会创建一个新的线程访问Servlet中的service的方法.在service方法内部根据请求的方式的不同调用doXXX的方法.(get请求调用doGet,post请求调用doPost).当Servlet中服务器中移除掉,或者关闭服务器,Servlet的实例就会被销毁,那么destroy方法就会执行.== Servlet生命周期分为三个阶段，初始化阶段，运行阶段，销毁阶段 初始化阶段默认在Servlet第一次被访问的时候执行，调用init方法执行一些初始化准备工作。浏览器每次发起请求则执行运行阶段调用service方法，执行具体业务流程。当服务器关闭或者项目被移除执行销毁阶段，调用destory方法，可以在destory方法中执行资源回收，连接关闭等工作。 初始化阶段和销毁阶段在整个生命周期过程中只执行一次，运行阶段可以执行多次 Servlet的配置Servlet默认是在第一次访问的时候创建的.现在让Servlet在服务器启动的时候创建好.进行对Servlet的配置:在web.xml中在&lt;servlet&gt;&lt;/servlet&gt;标签中配置:&lt;load-on-startup&gt;2&lt;/load-on-startup&gt; 传入正整数,整数越小,被创建的优先级就越高. url-pattern配置方式共有三种: 完全路径匹配 ：以 / 开始&lt;url-pattern&gt;/ServletDemo1&lt;/url-pattern&gt; 目录匹配 ：以 / 开始需要以 结束.`/aaa/` 扩展名匹配 ：不能以 / 开始 以 开始的. `.action` ==错误的写法 ：/*.do== structs2默认的是以.action为后缀，springmvc是以.do为后缀 Servlet路径编写 相对路径:都是需要找位置相对关系.不能以 / 开始的 ./ 当前路径 ../上一级目录使用相对路径访问: 绝对路径:不需要找位置相对关系. 以 / 开始的.绝对路径中分为客户端路径和服务器端路径: 客户端路径一定要加工程名. 服务器端路径不需要加工程名. ServletContext对象ServletContext对象存取数据,存的数据都是有一定的作用的范围的.这种对象称为是域对象.所有的Servlet都在ServletContext环境下(每一个项目有且只有一个ServletContext对象)ServletContext存取数据:存入数据:setAttribute(key,value)获取数据:Object getAttribute(key)移除数据:removeAttribute(key) ServletContext的作用: 用来获得全局初始化参数. 用来获得文件的MIME的类型. 作为域对象存取数据.(ServletContext是一个域对象) 作用范围:整个web工程. 创建:服务器启动的时候,tomcat服务器为每个web项目创建一个单独ServletContext对象. 销毁:服务器关闭的时候,或者项目从服务器中移除的时候. 用来读取web项目下的文件. ServletConfig 对象 1234567ServletConfig servletConfig = this.getServletConfig();String servletName = servletConfig.getServletName();System.out.println(servletName);String username = servletConfig.getInitParameter("username");String password = servletConfig.getInitParameter("password");System.out.println(username+" "+password); 123456789101112&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo7&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.a_servlet.ServletDemo7&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql]]></title>
    <url>%2FJavaWeb%2FJavaWeb%20-Mysql%2F</url>
    <content type="text"><![CDATA[Mysql基本概念是一个文件系统,存储数据,通过标准的SQLy语句获取数据 关系型数据库关系型数据库存放的是实体之间的关系 常见关系型如:mysql orcale db2 mysql 安装注意路径不能有空格 中文等 数据存储方式数据库服务器 --&gt;数据库 ---&gt;表(为每个实体创建一个表)--&gt;字段 一台数据库服务器中会创建很多数据库（一个项目，会创建一个数据库）。在数据库中会创建很多张表（一个实体会创建一个表）。在表中会有很多记录（一个对象的实例会添加一条新的记录）。 12345678graph TB数据库服务器--&gt;数据库1数据库服务器--&gt;数据库2数据库1--&gt;表1数据库1--&gt;表2数据库2--&gt;表3数据库2--&gt;表4 eg:表结构(table) id name age 1 张三 13 2 李四 15 netstat -ano 端口查看 tasklist /svc 任务列表 ipconfig /flushdns ip刷新 sql 结构化查询语言分类: DDL 数据定义语言 数据库/表的操作 create drop altet DCL 数据控制语言 grant if DML 数据操作语言 对数据进行操作 insert updata delete DQL 数据查询语言 select 数据库操作 创建数据库 CREATE DATABASE 数据库名称 CHARACTER SET 字符集 COLLATE; 字符集校对规则 eg: CREATE DATABASE; //字符集和校对规则可省略 查看数据库 SHOW DATABASES; 查看某个数据库的定义信息： SHOW CREATE DATABASE 数据库名称; 修改数据库 修改数据库字符集 ALTER 数据库名 CHARACTER SET 字符集; 删除数据库 DROP DATABASE 数据库名; 切换使用的数据库 use 数据库名; 查看正在使用的数据库 select database(); 数据类型 表中字段类型 Java中的类型 MySQL中的类型 byte/short/int/long tinyint/smallint/int/bigint float float double double boolean bit char/String char和varchar类型 //需要指定长度 Date date/time/datetime/timestamp File blob/text //很少用 注意:在mysql中 char代表是固定长度的字符或字符串 eg:char(8) 存入长度不够8用空格不齐 varchar代表的是可变长度的字符串 eg: varchar(8) 长度不够8不会不齐 datetime就是既有日期又有时间的日期类型,如果没有向这个字段中存值，数据库使用null存入到数据库中 timestamp也是既有日期又有时间的日期类型，如果没有向这个字段中存值，数据库使用当前的系统时间存入到数据库中 表的操作 创建表 CREATE TABLE 表名(字段名称 字段类型(长度) 约束,字段名称 字段类型(长度) 约束...); eg: CREATE TABLE person{ id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(10) UNIQUE, age INT }; 注意: 创建表之前要有数据库并使用数据库 约束可省略 约束 主键 PRIMARY KEY 默认非空唯一 非空 NOT NULL 唯一 UNIQUE 查看所有表 SHOW TABLES; 查看某个表的结构信息 DESC 表名; 查看表创建信息 SHOW CREATE TABLE 表名; 删除表 DROP TABLE 表名; 修改表 1）添加列 ALTER TABLE 表名称 ADD 列名 类型(长度) 约束; eg: ALTER TABLE t_address ADD phone VARCHAR(20); 2)修改列的类型、长度、约束 ALTER TABLE 表名称 MODIFY 类型(长度) 约束; eg： ALTER TABLE t_address MODIFY phone VARCHAR(30) NOT NULL; 3)修改列名 ALTER TABLE 表名称 CHANGE 旧列名 新列名 类型(长度) 约束; eg： ALTER TABLE t_address CHANGE phone tel VARCHAR(30) NOT NULL; 4)删除列 ALTER TABLE 表名称 DROP 列名; eg: ALTER TABLE t_address DROP tel; 5)修改表名 RENAME TABLE 表名 TO 新表名; 插入数据 1)INSERT INTO 表名(列名1,列名2,…,列名N) VALUES(值1,值2,…,值N);2)INSERT INTO 表名(列名1,列名2,…,列名N) VALUES(值1,值2,…,值N),(值1,值2,…,值N),…,(值1,值2,…,值N);3)INSERT INTO 表名 VALUES(值1,值2,…,值N); 更新数据 UPDATE 表名 SET 列名1=值1,列名2=值2,…,列名n=值n WHERE 条件; 删除数据 1)删除部分数据 DELETE FROM 表名 WHERE 条件; 2)删除表内所有数据 --DELETE是一条条删除，不会清空AUTO_INCREMENT DELETE FROM 表名; --属于DML,事务可以作用在DML上 --直接将表删除，重建，AUTO_INCREMENT重置为0 TRUNCATE TABLE 表名; --属于DDL 查询数据 基本查询 SELECT * FROM 表名 ; --查询所有 SELECT 列名1,列名2... FROM 表名 ; --查询指定列数据 SELECT DISTINCT 列名1... FROM 表名 ; --去重查询,参数所有列完全相同时去重 SELECT 列名1 AS 列名1别名,列名2 AS 列名2别名 FROM 表名 ; --别名查询,AS可以省略 条件查询 基本查询+WHERE 条件; SELECT * FROM 表名 WHERE 条件; 条件: &gt;, &lt; ,&gt;=, &lt;= ,&lt;&gt;, = like 模糊查询,使用_或%作为站位符,_代表一个字符,%代表任意个字符 in 范围查询 匹配内容 between .. and and ,or ,not eg: SELECT * FROM headset WHERE name LIKE &apos;李_&apos;; SELECT * FROM headset WHERE age IN(21,22,23); SELECT * FROM headset WHERE money BETWEEN 1000 AND 1800; 排序查询 order by 字段名 asc(升序默认可省略)/desc(降序); eg: select * from exam order by score; select * from exam order by score desc; select * from exam order by score desc,age asc; 分页查询 sql语句最后 limit 起始index,数目 聚合函数 count max/min sum avgeg: SELECT sum(english) from exam where name like ‘李%’; ifnull(字段,默认值) –当字段为空时以默认值计算 分组查询 SELECT 字段 ,COUNT(*) FROM 表名 GROUP BY 字段; 聚合函数通常和分组配合, where 后不能跟聚合函数 需要用having SELECT 字段 ,SUM(字段1) FROM 表名 GROUP BY 字段 HAVING 条件; 总结 S(select)… F(from)…W(where)…G(group by)…H(having)…O(order by); 多表约束外键约束:保证数据的完整性 alter table 表 add foreign key(字段) references 表a(字段a) 外键一般连接的都是主键 多表关系一对一 一的其中一方创建外键指向另一方的主键 主键绑定主键 一对多 多的一方创建外键指向一的主键 多对多 需要创建第三张表(中间表),在中间表中能够至少有两个字段作为外键分别指向多对多双方主键 多表查询####连接查询 交叉连接(了解) 两个表的笛卡尔积 select * from 表1 cross join 表2; select * from 表1 , 表2; 内连接 显示内连接 inner join (inner 可省略) select * from 表1 inner join 表2 on 关联条件; 隐士内连接 select * from 表1,表2 where 关联条件; 外连接 outer join (outer 可省略) 左外连接 select * from 表1 left outer join 表2 on 关联条件 右外连接 select * from 表1 right outer join 表2 on 关联条件 ####子查询 一个查询语句需要依赖另一个查询语句的结果 查询中嵌套查询 in any 任意一个 all 所有 exists select * from clsses where exists(selct cno from student where birthday&gt;&apos;1991-01-01&apos;) ###事务 特性 原子性 事务不可分割 一致性 事务执行的前后,数据的完整性保持一致 隔离性 一个事务的执行不应该受到其他事务的干扰 持久性 事务一旦提交结束 就因该保存到数据库中 开启事务 start transaction 提交事务 commit 回滚事务 rollback 隔离级别 基于隔离性出现的问题 脏读 一个事务查询到另外一个事务未提交的数据,导致查询结果不一致 不可重复读 一个事务读到了到另外一个事务已提交的update数据,导致多次查询结果不一致 虚读/幻读 一个事务读到了到另外一个事务已提交的insert数据,导致多次查询结果不一致 级别 read uncommitted read committed repeatable serializable JDBCjava数据连接 一组Java语言的类和接口 规范 驱动:两设备(应用)之间的通信桥梁 步骤 注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 获取连接对象 Connection con=DriverManager.getConnection(&quot;jdbc:mysql://ip地址:端口/数据库名称&quot;,数据库用户名,数据库密码); 获得一个操作sql对象 Statement sm= con.createStatement; 执行sql语句 获取结果 String sql =&quot;sql语句&quot;; ResultSet set=sm.executeQuery(sql); 查询 int row =sm.executeUpdate(sql); 增删改 处理结果 释放资源 set.close(); sm.close(); con.close() 12345678910111213141516eg:if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException sqlEx) &#123; // ignore &#125; rs = null;&#125;if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException sqlEx) &#123; // ignore &#125; stmt = null;&#125; ###JDBC 的sql 注入漏洞 把用户输入得参数当作sql关键字被解释执行 jdbc事务 环境准备 数据库及表 create database web_test; use web_test; create table account( id int primary key auto_increment, userName varchar(20), password varchar(20), money double ); insert into account values(null,zhangsan,12345); 开启事务 conn.setAutoCOmmit(false);//关闭自动提交 提交事务conn.commit(); 事务回滚conn.rollback(); 代码12 连接池创建和管理一个连接的缓存池的技术 连接的创建和销毁需要时间,在服务器初级化时就初始化一些连接放入连接池中,使用时可从内存中获取,在内存中效率高 1.自定义连接池 装饰着模式 2.Druid连接池 DuridDataSource ds =new DuridDataSource(); //手动 ds.setDriverClassName(&quot;&quot;); ds.setUrl(&quot;&quot;); ds.setPassword(&quot;&quot;); //配置文件方式 /* DriverClassName= url= username= password= */ Properties prop= new Properties() prop.load(InputStream) DruidDataSourceFaxtory.createDataSource(prop) //获得连接 ds.getConnection(); 3.c3p0连接池 ComboPooledDataSource ds =new ComboPooledDataSource(); ds,setDriverClass(&quot;&quot;); ds.setJdbcUrl(&quot;&quot;); ds.setUser(&quot;&quot;); ds.setPassword(&quot;&quot;); //获得连接 ds.getConnection(); DBUtils 对jdbc简单的封装而没有影响性能]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2FJavaWeb%2FJavaWeb%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTML Hyper Text Markup Language 超文本标记语言 标记语言：指的是通过一组标签的形式描述事物的一门语言用于制作页面（静态） 结构 一个HTML文件后缀名为.html 或 htm 123456789101112131415&lt;!-- 根标签--&gt;&lt;html&gt;&lt;!-- 头标签 基于当前页面的一些配置--&gt;&lt;head&gt;&lt;title&gt;html 标题&lt;/title&gt;&lt;!-- 配置字符集 seo优化--&gt;&lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;!-- 体标签 展示内容--&gt;&lt;body&gt;html body&lt;/body&gt;&lt;/html&gt; 标签分类 按标签写法 双边 &lt;body&gt;&lt;/body&gt; 单边 &lt;br /&gt; 按状态 行内 &lt;span&gt; 块级 &lt;div&gt; HTML 字体排版标签1234567891011121314151617&lt;font&gt; 字体便签&lt;font color="red" size="12" face="宋体"&gt;&lt;/font&gt;属性 color 字体颜色英文单词 red black..使用16进制 #FFFFFF , #FFFF属性 size 字体大小从1 到 7属性 face 字体&lt;br /&gt; 换行标签&lt;h1 &gt;&lt;/h1&gt; 标题标签 ... &lt;h6&gt;&lt;/h6&gt;&lt;p&gt;&lt;/p&gt; 段落标签&lt;b&gt; &lt;/b&gt; 字体加粗&lt;i&gt;&lt;/i&gt; 斜体标签&lt;u&gt;&lt;/u&gt; 下划线标签&lt;center&gt; &lt;/center&gt;内容居中&lt;hr&gt;&lt;/hr&gt; 分隔线&lt;pre&gt;&lt;/pre&gt; 预定义标签 将字符串原封不动的显示出来 HTML 图片标签 &lt;img&gt; 图片标签 属性 src ： 图片来源 width : 图片的宽度. height: 图片的高度. alt : 图片找不到显示的内容. 12eg:&lt;img src="a.png" width=100% height=100% alt="img"/&gt; HTML 列表标签 无序 ul li 属性 type 类型 circle 空心点 disc 实心点 默认 square 方块 1234&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 有序 ol li 属性type 类型 1 数字型 a 英文型 i 罗马字符型 start 从哪个开始 1234&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 超链接标签 &lt;a&gt; 属性 href :链接的路径 target :打开的方式 _self :在自身页面打开 _blank :新打开一个页面 table标签12345&lt;table&gt;&lt;tr&gt;&lt;!--行--&gt;&lt;td&gt;&lt;/td&gt; 列&lt;/tr&gt;&lt;/table&gt; 属性width ； 表格宽度height：表格高度border ： 边框Align: 水平位置leftrightcenter 属性合并单元格colspan=”列数”rowspan=”行数” 表单标签 &lt;form&gt; action 提交的路径，默认当前页面 method 请求方式，GET 和POST 默认为GET 表单中的元素&lt;input&gt; 文本框 &lt;input type=&quot;text&quot;/&gt; 文本框 属性 type： 类型 text 文本框 password 密码框 radio 单选按钮 checkbox 复选按钮 button 普通按钮 submit 提交按钮 reset 重置按钮 file 文件上传的表单项 hidden 隐藏字段 image 图片按钮 name: 表单元素名称 必须有 value: 文本框默认值 size: 文本框长度 maxlength: 最大输入长度 readonly: 只读 checked: 单选/复选按钮默认选中 &lt;select&gt; 下拉列表 name 属性 &lt;option&gt; value 属性 #####&lt;textarea&gt; 文本域 cols rows 框架标签 frameset 注意 与body 标签冲突 属性 rows cols 两者只能出现其一 使用&lt;frame&gt; 标签 frame代表分切的每个部分 属性 src 网页的连接 name 指定名称 可以通过a标签跳转 onresize 让frame边框不能拖动 1234567&lt;frameset rows=2&gt;&lt;frame&gt;&lt;/frame&gt;&lt;frameset cols=2&gt;&lt;frame&gt;&lt;/frame&gt;&lt;frame&gt;&lt;/frame&gt;&lt;/frameset&gt;&lt;/frameset&gt; css 层叠样式 div +css 页面布局 对页面进行美化 块标签&lt;div&gt;&lt;/div&gt; ： 默认一个独占一行 行内标签&lt;span&gt;&lt;/span&gt; : 默认不换行 基本语法引入方式####行内式 直接标签内使用style 属性&lt; h1 style=&quot;color:red;&quot;&gt;&lt;/h1&gt; ####内联式 使用style标签,一般放在head 标签内 12345&lt;style&gt;h1&#123;color:red;&#125;&lt;/style&gt; ####外联式 单独定义.css文件在HTML中link标签中引入 123456.css文件中h1&#123;color:red;&#125;html中 使用link 标签&lt;link href=&quot;.css文件路径&quot; type=&quot;text/css&quot; /&gt; 选择器声明 属性:值 选择器{属性:值;属性:值…} 元素选择器 根据标签名称 div{} ####id选择器 根据标签id属性值 _id #_id{} 类选择器 根据标签class属性值 _class ._class{} 其他选择器属性选择器eq: input[type=&quot;text&quot;]{ } 后代选择器div span{} 查找所有div 中的所有span标签 #####子元素选择器 div &gt; span{} 查找所有div 中的第一层是span标签 相邻选择器div + span{} 并列选择器选择器1,选择器2{} 浮动CSS float 属性 值 描述 left 元素向左浮动。 right 元素向右浮动。 none 默认值。元素不浮动，并会显示在其在文本中出现的位置。 inherit 规定应该从父元素继承 float 属性的值。 清除浮动 使用clear 属性 1234&lt;div style="float:'left'"&gt;&lt;div&gt;&lt;div style="clear :'none'"&gt;&lt;div&gt; 定位position 绝对定位 absolute 相对定位 relative 盒子模型 内边距 pedJSKSJding 边框 border 外边距 margin JS 脚本语言 ##组成 ECMAScript: 基本语法 DOM document object model 文档对象模型 BOM browser object model 浏览器对象模型 ##语法区分大小写 ###弱变量类型语言(与java不同) 变量命名 var i =3;//整数型 var i =”3”;//字符串类型 ###数据类型 undefined 未定义 boolean number string object ###运算符 与Java中基本一致 js中=== 全等 类型和值都一致才为true 语句与Java语句一致 ##开发步骤 通常由一个事件触发 事件触发后引用函数 调用函数 定义函数function 函数名(){ 函数体 } 匿名函数 window.onload=function(){}常用事件 onclick 点击事件 onsubmit 提交 onchange select选中 onfocus 获得焦点 onblur 失去焦点 onload 页面加载 12345eg:var br=doucment.getElementById(&quot;id&quot;);br.onclik(function()&#123;//...&#125;); js引入方式使用script 标签&lt;script&gt; js内容 &lt;/script&gt; 引入.js 文件&lt;script src=&quot;js文件&quot;&gt;&lt;/script&gt; 正则&quot;&quot;.match(/正则表达式/) /正则表达式/.test(&quot;&quot;) ##获得页面元素 document.getElementById(“id”); window中setTimeout(一定时间后执行) setInterval(每隔一定时间执行) eg: setInterval(function(){ },1000); setTimeout(function(){ },1000); JQuery 一个js 的框架(类库) ##引入 $(function(){ //$相当于JQuery 对象 //等页面的Dom树绘制完成后执行 }); js/jq对象转换###js对象转jq对象 $(js对象) ###jq对象转js对象 var $d1=$(“#id”);//jq对象 $d1 变量名可起其他名 #id 为 #+标签id eq: var a =$(#id); $d1[0];或 $d1.get(0);//转为js对象 ##显示与隐藏 $(选择器).show(); $(选择器).hide(); $(选择器).toggle(); 当标签隐藏时显示,显示时隐藏 用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。 如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。 ###基本 show([speed,[easing],[fn]]) hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) ###滑动 slideDown([spe],[eas],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 注意要设置标签的宽度 ###淡入淡出 fadeIn([speed],[eas],[fn]) fadeOut([speed],[eas],[fn]) fadeTo([[spe],opa,[eas],[fn]]) fadeToggle([speed,[eas],[fn]]) ##选择器 $(选择器) ###基本 #id id选择器 .class 类选择器 元素名 元素选择器 * 通配选择器 选择器1,选择器2 并列选择器 层级选择器ancestor descendant 后代选择器 使用空格 eg: $(body div) body 下的所有的div标签 parent &gt; child 子元素选择器 使用&gt; eg:$(body&gt;div) body下的第一层div标签 prev + next 下一个元素 使用+ eg:$(#id+div) id标签的下一个标签 prev ~ siblings 兄弟元素 使用~ eg:$(#id~div) id标签的所有兄弟标签 基本过滤:first 第一个元素 :last 最后一个元素 :odd 奇数元素 :even 偶数元素 :eq(index) 下标为index 元素 内容过滤 :contains(text) 内容为text的元素 属性[attribute] [attribute=value] 匹配给定的属性是某个特定值的元素 [attribute!=value] 匹配所有不含有指定的属性，或者属性不等于特定值的元素 [attribute^=value] 匹配给定的属性是以某些值开始的元素 [attribute$=value] [attribute*=value] [attrSel1][attrSel2][attrSelN] 表单选择器和表单属性选择器:input 所有的表单标签 checked checkbox 或 radio 被选中 selected select被选中 添加和移除样式* 如果样式没有事先定义,可以使用css方法为奇数行或者偶数行设置背景颜色. css(&quot;属性&quot;,&quot;值&quot;) css(&quot;属性1:值1&quot;,&quot;属性2:值2&quot;) * 如果已经在css文件中事先将样式定义完成了,不能使用css方法了.使用JQ中的CSS类中的方法： * addClass(); * removeClass(); eg: $(&quot;tr&quot;).addClass(&quot;&quot;); 标签属性操作attr(); 高版本会失效 prop(); 获取设置属性 prop(&quot;属性&quot;) prop(&quot;属性&quot;,&quot;值&quot;) removeProp() 移除属性 操作文档对象 append() 添加 appendTo() 添加到 html() 替换内容 遍历$().each(function(i,n){ // i代表index ,n代表当前元素 }) $.each(数组,function(i,n){}) 事件切换toggle(); 用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。 如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。 eg: 对表格切换显示/隐藏 $(&apos;td).toggle(); 对表格的切换一个类 $(&quot;td&quot;).toggle( function () { $(this).addClass(&quot;selected&quot;); }, function () { $(this).removeClass(&quot;selected&quot;); } ); trigger和triggerHandler的区别1.trigger和triggerHandler都会触发自己实现的逻辑 2.trigger会导致系统的事件和自己定义的逻辑都被触发 3.triggerHandler只会触发自己实现的逻辑,不会触发系统的事件 4.trigger会对所有匹配到的元素都执行相关逻辑 5.triggerHandler他只会对匹配到的元素的第一个执行自己的逻辑,并且不会执行系统的事件 6.trigger会导致事件冒泡.triggerHanlder不会导致事件冒泡 BootStrap 前端响应式框架 引入bootstrap文件 注意先引入jquery在引入bootstrap.js 1234&lt;link rel="stylesheet" href="css/bootstrap.min.css" /&gt;&lt;link rel="stylesheet" href="css/bootstrap-theme.min.css" /&gt;&lt;script type="text/javascript" src="js/jquery-1.8.3.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/bootstrap.min.js"&gt;&lt;/script&gt; 添加&lt;meta&gt;标签&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 全局css布局容器.container .container-flue 栅格系统12列 .row 行 .col-lg-n .col-md-n .col-sm-n .col-xs-n 四种列样式,n是数字1-12代表占行的份额,行的总份额为12 12345678910eg:&lt;body&gt;&lt;div class="container"&gt;&lt;div class="row"&gt;&lt;div class="col-md-4"&gt;&lt;/div&gt;&lt;div class="col-md-4"&gt;&lt;/div&gt;&lt;div class="col-md-4"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; javaScript插件轮播]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>HTML</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http]]></title>
    <url>%2FJavaWeb%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP协议 超文本传输协议,用来规定浏览器和服务器之间要遵守的协议 特点 基于请求和响应的模型 必须现有请求后有响应 请求和响应成对出现 协议详解TCP/IPTCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，定义了主机如何连入因特网及数据如何再它们之间传输的标准，从字面意思来看TCP/IP是TCP和IP协议的合称，但实际上TCP/IP协议是指因特网整个TCP/IP协议族。不同于OSI模型的七个分层，TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等传输层：TCP，UDP网络层：IP，ICMP，OSPF，EIGRP，IGMP数据链路层：SLIP，CSLIP，PPP，MTU每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的建立TCP连接的三次握手 Socket套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议， 本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。 httpHttp协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。在HTTP 1.0中客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。虽然这里使用TCP连接保持了一段时间，但是这个时间是有限范围的，到了时间点依然是会关闭的，所以我们还把其看做是每次连接完成后就会关闭。Http连接是一种短连接，是一种无状态的连接。所谓的无状态，是指浏览器每次向服务器发起请求的时候，不是通过一个连接，而是每次都建立一个新的连接。如果是一个连接的话，服务器进程中就能保持住这个连接并且在内存中记住一些信息状态。而每次请求结束后，连接就关闭，相关的内容就释放了，所以记不住任何状态，称为无状态连接。如果要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即使不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。通过Session, Cookie等相关技术，也能保持一些用户的状态。但是还是每次都使用一个连接，依然是无状态连接。Http协议指定的端口是 80，所以一般计算机上不会限制这个端口，所以Http协议能够顺利通过所有机器上的防火墙。 HTTP，socket，TCP/IP：网络由下往上分为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层，三者从本质上来说没有可比性socket则是对TCP/IP协议的封装和应用(程序员层面上)。TPC/IP协议是传输层协议，主要解决数据如何在网络中传输HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。如果想要使传输的数据有意义，则必须使用到应用层协议。应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。通过Socket，我们才能使用TCP/IP协议。实际上，Socket跟TCP/IP协议没有必然的联系。Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。关于socket和TCP/IP协议关系的说法比较容易理解：“TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。”有个比较形象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。 状态码 200 ：成功 302 ：重定向 304 ：查找本地缓存 404 ：资源不存在 500 ：服务器内部错误更多状态码]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat]]></title>
    <url>%2FJavaWeb%2FWEB%E5%B7%A5%E7%A8%8B-Tomcat%2F</url>
    <content type="text"><![CDATA[Tomcat发布一个WEB工程##常见WEB服务器 Apache :发布PHP的. LAMP:Linux Apache MySQL PHP. IIS :发布ASP的. WebSphere、WebLogic、Jboss Nginx ， Tomcat Apache组织研发,免费的小型的服务器软件,支持Servlet/JSP的开发规范 Tomcat安装及目录结构安装 官网下载 解压即可 注意:路径不能有中文 配置环境变量 配置JAVA_HOME环境变量 指向JDK 安装目录 目录结构 bin tomcat的执行的文件. conf tomcat的配置文件. lib tomcat运行的需要的jar包. logs tomcat的运行的日志文件. temp tomcat产生临时文件存放的路径. webapps tomcat发布的web项目的路径. work tomcat运行JSP的时候,JSP翻译成Servlet的代码存放的路径. 发布一个WEB工程到Tomcat中 共有三种方式: 1.直接将工程copy到tomcat/webapps下. 将工程复制到webapps即可. 2.配置tomcat虚拟路径-不推荐： 在tomcat/conf/server.xml文件中进行配置: 在标签下配置: &lt;Context path=&quot;/itheima&quot; docBase=&quot;C:/website&quot;/&gt; 3.配置tomcat虚拟路径-推荐： 在tomcat/conf/Catalina/localhost/xxx.xml 配置&lt;Context docBase=&quot;C:/website&quot;/&gt; xxx作为虚拟路径的名称. eclipse开发web项目server配置 选择window下的Perferences弹出窗口 左侧找到Server下的Runtime Enviroment 点击Add按钮 然后选择apchae Tomcat v7.0(也可以是其他版本) 单击Next 填写Tomcat istallation directory 安装目录 然后 Finish]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE加强]]></title>
    <url>%2Fjava%2FJavaSE%E5%8A%A0%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[面向对象封装static 关键字 修饰成员变量和方法 内部类 ####特点： 随着类的加载而加载 优先于对象存在 被类的所有对象共享 可以被类名调用 优缺点： 优点: 对象共享数据，节省空间 被类名直接调用 缺点: 访问有局限性 代码块 在java中，使用{}括起来的代码被称为代码块 ####分类 #####局部代码块 在方法中出现，控制变量生命周期，及早释放，提高内存利用率 #####构造代码块 在类中方法外出现，抽取构造方法中的共性，每次创建对象都会执行，并且在构造方法前执行 #####静态代码块 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。 一般用于加载驱动 #####同步代码块 继承 多个类有共同的成员变量和方法，抽取到另一个类中（父类）在让多个类继承父类 格式：class 子类 extends 父类 {} 特点 在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类,但多个类可以继承一个父类 在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类 在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类 成员变量 子类只能获取父类的非私有成员 super 可以获取父类的成员变量和成员方法，用法与 this 相似 方法重写 当父类方法不能完成满足子类使用 用注解 @Override：方法重写，说明下面的方法是重写父类的方法 注意事项： 不能继承父类私有成员 权限修饰符必须大于等于 继承中构造方法的执行顺序A:super(实参列表);语句 在子类的构造方法中使用,用来调用父类中的构造方法(具体哪一个由传递的参数决定),并且只能在构造方法第一行使用 B:this(实参列表); 语句 在类的构造方法中使用,用来调用本类中的其它构造方法(具体哪一个由传递的参数决定),并且只能在构造方法的第一行使用 匿名对象没有变量引用的对象 当方法只调用一次时使用 final关键字final： 修饰符，可以用于修饰类、成员方法和成员变量 final所修饰的类：不能被继承，不能有子类 final所修饰的方法:不能被重写 final所修饰的变量：是不可以修改的，是常量 抽象类abstract 修饰符 用于方法和类 有抽象方法的类必须是抽象类 抽象类的特点： 抽象方法只能在抽象类里面 抽象类和抽象方法必须被abstract修饰 抽象类不能创建对象（不能实例化） 抽象类中可以有非抽象的方法 抽象类和类的关系也是继承 一个类继承了抽象类要么重写所有的抽象方法，要么他自己是抽象类 static 修饰的方法不会被继承 接口处理单一继承的局限性 比抽象类还抽象的类，接口里所有的方法都是抽象方法，接口和类的关系是实现 implements 定义格式：public interface 接口名 { 抽象方法1; 抽象方法2; } 使用class 类 implements 接口 { 重写接口中方法 } 特点只能有抽象方法 方法只能使用pulic abstract 修饰符 默认使用 可省略 只能有常量 常量只能使用pulic static fianl 修饰符 默认使用 可省略 类与接口关系类与类之间:继承关系,一个类只能直接继承一个父类,但是支持多重继承 类与接口之间:只有实现关系,一个类可以实现多个接口 接口与接口之间:只有继承关系,可以多重继承 优点打破继承的局限性 对外提供规则 降低了程序的耦合性 接口和抽象类的区别1.共性： 不断的进行抽取，抽取出抽象的，没有具体实现的方法,都不能实例化（不能创建对象） 2.区别 与类的关系 类与接口是实现关系，而且是多实现，一个类可以实现多个接口，类与抽象类是继承关系，Java中的继承是单一继承，多层继承，一个类只能继承一个父类，但是可以有爷爷类 成员 a.成员变量 抽象类可以有成员变量，也可以有常量 接口只能有常量，默认修饰符public static final b.成员方法 抽象类可以有抽象方法，也可以有非抽象方法 接口只能有抽象方法，默认修饰符 public abstract c.构造方法 抽象类有构造方法，为子类提供 接口没有构造方法 多态 多态是继封装、继承之后，面向对象的第三大特性 前提 子父类 方法重写 父类引用指向子类对象 动态绑定 运行期方法调用是根据其具体类 优点 可维护性 可扩展性 包：多层结构 不同包下文件名可相同 必须在第一行声明 类的全名 包名.类名 使用import 类的全名 将类导入 修饰符 权限修饰符 public protected default private 同一类中 √ √ √ √ 同一包中(子类与无关类) √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 修饰符 类 成员变量 成员方法 构造方法 public Y Y Y Y default Y Y Y Y protected Y Y Y private Y Y Y abstract Y Y static Y Y final Y Y Y 内部类 将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。其他类也称为外部类。 成员内部类在类的成员位置 可以访问外部类的成员包括私有成员 外部类.内部类 对象名 = new 外部类().new 内部类(); 局部内部类 在方法内，出了方法就无法使用 匿名内部类可以看做没有名字的局部内部类 格式 new 类/接口 (){ 有抽象方法就必须实现具体方法体 }; 原理： 创建了这个类（接口）的子类对象 APIObject 类层次结构的根类 ###方法 12toString()equals(Object obj) System 不能被实例化 包含一些有用的字段和方法 方法123456789arraycopy(Object src, int srcPos, Object dest, int destPos, int length)从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。currentTimeMillis() 返回以毫秒为单位的当前时间 exit(int status) 终止当前正在运行的 Java 虚拟机 Date 表示特定的瞬间，精确到毫秒 构造函数Date() 创建当前系统时间的Date对象 Date(long date) 创建指定时间的Date对象 方法 setTime(long time) long getTime() 大部分方法已过时 Calendar类代替 DateFormat 抽象类 已知实现子类SimpleDateFormat SimpleDateFormat构造函数SimpleDateFormat() 默认模式创建对象 SimpleDateFormat(String pattern)指定模式创建对象 方法Date parse(String text)解析字符串的文本，生成 Date。 String format(Date date) 将给定的 Date 格式化为日期/时间字符串。 12345678 例： SimpleDateFormatsdf = new SimpleDateFormat("yyyy年MM月dd日HH:mm:ss");Date date = new Date();String s = sdf.format(date)-----------------String now = "2000-01-01"；SimpleDateFormatsdf = new SimpleDateFormat("yyyy-MM-dd")Date d2 = sdf.parse(now); Calendar抽象类 已知实现子类GregorianCalendar Calendar c = Calendar.getInstance(); c.get(Calendar.DAY_OF_MONTH ) 包装类由于基本数据类型只能做一些简单的操作和运算，所以java为我们封装了基本类型。 自动装箱和拆箱 从JDK1.5 开始 正则表达式一套规则可以用于比配字符串 Pattern Matcher 字符 x 字符 x \\ 反斜线字符 字符类 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） 预定义字符类 . 任何字符（与行结束符可能匹配也可能不匹配） \d 数字：[0-9] \D 非数字： [^0-9] \s 空白字符：[ \t\n\x0B\f\r] \S 非空白字符：[^\s] \w 单词字符：[a-zA-Z_0-9] \W 非单词字符：[^\w] 数量词 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 集合Collection基本概念接口Collection 层次结构的根1234boolean add(E e)void clear()boolean contains(Object o)boolean isEmpty() 遍历方式1、toArray() 把集合变成数组，然后遍历数组 2、iterator() 迭代器对象，通过迭代器对象迭代集合 Iterator 类 Object next() 下一个元素 boolean hasNext() 判断是否有下一个元素 增强for循环for(元素类型 元素变量：集合或数组对象){ 可以直接使用元素变量 } 在增强for循环中不能修改集合，否则会发生并发异常 并发修改异常在使用迭代器是不允许集合有修改（增加、删除），否则会抛出异常 解决办法 使用迭代器自身去修改集合 ##泛型 是一种广泛的类型，把明确数据类型的工作提前到了编译时期，借鉴了数组的特点 特别注意：泛型只能写引用数据类型。 泛型的好处 避免了类型转换的问题 可以减少黄色警告线 可以简化我们代码的书写 类名上的泛型class Box&lt;E&gt;{} 方法上的泛型public &lt;T&gt; T method(T t){ return t; } 泛型上下限? extends 类名1 泛型上限 ？ super 类名2 泛型下限 常见数据结构数组： 长度一旦定义就不能改变 有整数索引 只能存储同一种类型的元素 即可以存储基本数据类型也可以存储引用数据类型 查找快 增删慢 链表 由链子连接起来的一堆节点 特点:查询慢 增删快 栈 先进后出 队列 先进先出 List有序 存储顺序有序 索引 允许重复 子类 ArrayList 底层是数组结构 查询快 增删慢 LinkedList 底层是链表结构 查询慢 增删快 方法 addFirst(E e) getFirst() removeFirst() addLast(E e) getLast() removeLast() HashSetList的子类 无序（存储和读取的顺序） 元素唯一 Collections 集合工具类 方法1234567891011int binarySearch(List list,T key) //二分查找指定元素的下标,注意list必须排序完毕 copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) // 把源列表数据覆盖到目标列表，注意目标列表的长度至少必须等于源列表fill(List&lt;? super T&gt; list, T obj) //使用指定元素替换指定列表中的所有元素 shuffle(List&lt;?&gt; list) //使用默认随机源对指定列表进行置换。 sort(List&lt;T&gt; list) //根据元素的自然顺序 对指定列表按升序进行排序。 swap(List&lt;?&gt; list, int i, int j) //在指定列表的指定位置处交换元素。 Map 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 与Collextion的区别 Map : 双列集合 通常处理有对应关系的数据 key是不可重复的 Collection: 单列集合，有不同子类体系 常用功能 增 put(key ,value) 删 clear() 清除所有 remove(Object e) 移除 查 get(Object key) 异常 包含错误的类型、原因、位置 ##体系结构 123graph TDThrowable--&gt;ErrorThrowable--&gt;Exception 处理方式 出现异常未处理 jvm帮我们处理 控制台打印异常信息并终止程序 捕获处理 try ... catch try{ 可能出现问题的代码 }catch(异常类 异常){ } 抛出去 12345678 方法（） throws 异常类 &#123;&#125;新 try(FileWriter fw = new FileWriter(&quot;a.txt&quot;))&#123;//自动关流 fw.write(&quot;&quot;); &#125;catch(Exception e)&#123; &#125; 异常种类###运行时异常 RuntimeException 的子类，在运行时期的异常 编译时异常 Exception子类RuntimeException子类非编译时期必须处理 IO流File类构造方法123File(File parent,String child)File(String path)File(String parent,String child) 方法12345creatNewFile() //创建文件mkdir() //创建文件夹mkdirs()delete() //删除文件，isAbsolute() 路径是否是绝对路径 分类标准输入输出流 System.in System.out 转换流 把字节流转换为字符流 outputStreamWriter inputStreamReader 打印流 打印流添加输出数据的功能，使它们能够方便地打印各种数据值表示形式. 字符打印流 PrintWriter void print(String str): 输出任意类型的数据， void println(String str): 输出任意类型的数据，自动写入换行操作 对象流 用于从流中读取对象的 ObjectInputStream称为 反序列化流,利用输入流从文件中读取对象 ObjectOutputStream 称为 序列化流,利用输出流向文件中写入对象 特点：用于操作对象。可以将对象写入到文件中，也可以从文件中读取对象。 多线程概念进程：一个应用程序在内存中执行区域线程：进程中的一个执行控制单元 一个进程可以有多个线程 多线程实现 方式一 继承Thread 类 重写run方法 创建对象 启动 start() 方式二 实现Runnable 接口 网络 设备之间的数据通讯 Socket 三要素ip 网络设备的标识 端口 用于标识进程的逻辑地址 传输协议 udp tcp ip InerAddress表示网络协议（IP) 地址 InetAddress address =InetAddress.getByName(&quot;itheima&quot;);//通过主机名获取InetAddress InetAddress address =InetAddress.getLocalHost();//本地主机InetAddress Udp发送过程1234567891011121314 //创建Socket对象 DatagramSocket ds =new DategramSocket();//创建socket对象随机分配端口 //DatagramSocket ds =new DategramSocket(1000);指定端口 //创建数据并打包 //DatagramPacket 数据包类 byte[] bys;//数据 InetAddress addr = InetAddress.getByName("");//ip地址 int port ;//端口 DatagramPacket dp = new DatagramPacket(bys,bys.length,addr,port); // 发送数据 ds.send(dp); //关闭资源 ds.close(); 接收过程1234567891011121314 //创建Socket对象 DatagramSocket ds =new DategramSocket(1000);//指定端口//接收数据byte[] bys = new byte[1024];DatagramPacket dp = new DatagrmPacket(bys,bys.length);ds.receive(dp);//拆分数据InetAddress addr =dp.getAddress();int length =dp.getLength();//数据长度//byte[] data =dp.getData();//数据会在bys 中//关闭资源ds.close(); Tcp发送123456789 //创建socket对象 Socket socket = new Socket(InetAddres.getByName(""),10086);// 获取输出流对象OutputSteam os socket.getOutputStream();// 发送数据 os.write(""); //关闭资源 socket.close(); 接收12345678910 ServerSocket ss = new ServerSocket(10086); //监听Socket socket = ss.accept();//获得输入流InputStream is =socket.getInputStream();byte[] bs = new byte[1024];int len =is.read(bs);is.close(); 反射 运行过程中获取对象，对象中的成员 获取字节码对象Class clz =Class.forName(&quot;类的全名&quot;); 获取构造方法Constructor[] cs= clz.getConstructors() //获取所有public 构造方法 Constructor c =clz.getConstructor();//获取无参构造 Constructor c =clz.getConstructor(T.class,..);//获取有参构造 创建对象Object o = c.newInstance();//无参 c为无构造 Object o = c.newInstance(...);//有参 传递实参 c为有参构造 获取成员字段Field field =clz.getField(); Field[] getFields(); public 字段 getDeclarefields(); 所有的字段 field.get(o) //获取o对象上的field字段的值 field.setAccessible(true) //设置反射取消java访问检查 field.set(o,值) //给o对象上的field字段设值 获取成员方法Method m = clz.getMethod(&quot;method&quot;,形参类型); m.Invoke(o,实参); 调用方法]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>进阶学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础]]></title>
    <url>%2Fjava%2FJavaSE%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JavaSE基础##环境搭建 安装JDK配置环境变量JVM JRE =JVM +类库 JDK =JRE+java开发工具 数据类型基本数据类型 整数 byte 一个字节 short 两个字节 int 四个字节 long 八个字节 小数 float 4个字节 double 8个字节 字符 char 2个字节 布尔 boolean float double 在内存中存放结构 float一共32位，其结构定义如下： |—— 31 —–|—- 30-23 —— |—— 22-0 —–| 符号位(sign) 指数部分(exp) 小数部分(mag) sign:符号位就一位，0表示正数，1表示负数 exp: 指数部分，无符号正数 mag:小数部分，定点小数，小数点在最左边。 float的表达式 : pow(-1,sign) (1+mag) pow(2,exp-127) 引用数据类型数组 对象(new出来的) 需要注意的 1234byte a=10,b=20;byte c=a+b;//编译通不过，byte short char 做+、-、*、/运算时结果为int类型byte b = 3;//java有常量优化机制 , 3 为常量 在取值范围内jvm会自动强制转换 常量、变量 变量定义格式 数据类型 变量名 = 初始化值； 例： int a=10; 算数运算+ - * / % ++ -- 逻辑运算&amp; | ！ ^ &amp;&amp; || 三元运算符关系表达式？表达式1：表达式2； int c=a&gt;b?a:b; 不能单独存在,结果必须被接收 条件语句12345678if(条件)&#123;&#125;switch()&#123; case 值: break; default: break;&#125; 循环语句123456for(;;)&#123;&#125;while()&#123;&#125;do&#123;&#125;while(); 跳转语句 break continue return 数组声明数组：数据类型[] 数组名； 数组赋值： 数组名=new 数组类型[数组长度]； 数组名=new 数组类型[]{数据1，数据2，…}； 数组进行初始化 a:动态初始化 只指定长度，由系统给出初始化值 int[] arr = new int[5]; b:静态初始化 给出初始化值，由系统决定长度 int[] arr = new int[]{1,2,3,4,5}; 简写：int[] arr = {1,2,3,4,5}; c 不能动静结合的初始化 如int[] arr = new int[5]{1,2,3,4,5};编译不会通过1234//例子：int[] arr =new int[5];//动态初始化int arr =new int[]&#123;1,2,3,4,5&#125;;//静态初始化int arr =new int[5]&#123;1,2,3,4,5&#125;; //错误的表示编译报错 二维、多维数组 int[][] arr=new int[m][n]; 排序 冒泡排序123456789for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j+1 &lt; arr.length-i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; int temp =arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125;&#125; *选择排序123456789for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i+1; j &lt; arr.length; j++) &#123; if (arr[i] &gt; arr[j]) &#123; int temp =arr[i]; arr[i] =arr[j]; arr[j] = temp; &#125; &#125;&#125; 方法（函数）定义： 声明：大括号前面的内容 内容：大括号里面的内容 修饰符 返回类型 方法名（参数类型 参数1，参数类型 参数2....）{ //return ;//当返回类型为void 是可以省略，可以不带值 return 返回值；//返回值的类型必须与返回类型匹配 } 面向对象 面向过程:一步一步的执行 强调过程 面向对象:是一种思想基于面向过程的 将过程封装起来是一种更符合我们思考习惯的思想复杂变简单执行者变成指挥者 Java语言最基本的单位-类 类：是一组相关的属性和行为的集合 对象：就是该事物的具体体现 三大特性 封装 将不需要对外提供的内容都隐藏起来 继承 多态 构造方法 与类名一致 不写返回值类型 1234class Person&#123; public Person()&#123;//构造方法 &#125;&#125; javaBean规范 空参构造 属性私有化 提供setXXX(…) getXXX() API 应用程序接口 String类构造方法123String(String original)String(char[] value)String(char[],int index,int count)//把字符数组的一部分变成字符串对象 字符串的内容存储在方法区的常量池中的，方便字符串的重复使用 常用方法1234boolean equals(Object obj):比较字符串的内容是否相同boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写boolean startsWith(String str):判断字符串对象是否以指定的str开头boolean endsWith(String str):判断字符串对象是否以指定的str结尾 StringBulider类IO流 可以把数据存储到文件也可以从文件中读取数据 分类 按方向： 输入流 输出流 按功能： 节点流 处理流 按数据 字节流 字符流FileWriter 类构造方法 123FileWriter(File file)FileWriter(String fileName)FileWriter(String fileName,boolean flag) //flag表示是否在文件末尾追加写入 默认false 常用方法123456write(String str) //写字符串wirte(String str,int index,int len)write(char ch)wirte(char ch,int index,int len)flush() //刷新close() //关闭流释放资源，流将不能再使用了 使用步骤 创建对象，关联文件 调用输出流对象的写数据方法write(String str) 关闭资源1234//例子：FileWrite fw =new FileWriter("D:\\a.txt");fw.write("IO流");fw.close(); 换行符window : \r\n linux :\n max :\r FileReader类构造方法12FileReader(Flie flie)FileReader(String fileName) 常用方法12int read();close() 使用步骤 创建输入流对象 调用输人流对象的读数据方法read() 关闭释放资源1234例子：FileReader fr =new FileReader (&quot;D:\\a.txt&quot;);int a = fr.read();fr.close(); BufferedWriter 类 高效的写字符输出流构造方法1BufferedWriter(FileWriter fileWriter) 常用方法1234write(String s)flush();close()newLine(); //写一个换行符 12345//例子BufferedWriter bw = new BufferedWriter(new FileWriter("a.txt"));bw.wirte("abv")bw.flush();bw.close(); BufferedReader类 高效的文本读取构造方法1BufferedReader(FileReader fr) 常用方法1234read()flush();close()readLine() 一次读一行字符不包括换行符 12345//例子BufferedReader br = new BufferedReader(new FileReader("a.txt"));int c = bw.read()bw.flush();bw.close();]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2FMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 强调星号与下划线都可以，单是斜体，双是粗体，符号可跨行，符号可加空格 **一个人来到田纳西** __毫无疑问__ *我做的馅饼 是全天下* _最好吃的_ 斜体和粗体代码： *斜体*或_斜体_ **粗体** ***加粗斜体*** ~~删除线~~ 分割线三个或更多-_*，必须单独一行，可含空格 --- *** ___]]></content>
  </entry>
  <entry>
    <title><![CDATA[xml]]></title>
    <url>%2FjavaWeb%2Fxml%2F</url>
    <content type="text"><![CDATA[什么是xml可扩展标记语言 功能传输和存储数据 软件的配置文件 使用xml语法基本语法:- XML必须有关闭标签 - 区分大小写 - 属性需要有引号 - 标签必须正确嵌套. 文档声明 注释 元素 属性 特殊字符和CDATA区 文档声明通常出现在xml 文档的第一行第一列12345&lt;?xml 属性名=&quot;值&quot; ... ?&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;* version :必须的. 使用”1.0”* encoding :字符集. 是使用浏览器打开的时候采用的默认的字符集的编码.* standalone :描述XML文档是否需要依赖其他的文件. 注释&lt;!-- 注释内容 --&gt; 元素(标签)命名规范 字母 数字 及其他字符 不能以数字或标点符号开始 不能以字符”xml”(“XML/Xml”)开始 不能包含空格 属性属性的名称规范与元素一致 需要引号 特殊字符和CDATA区#####特殊字符 &amp;lt; &lt; 小于 &amp;gt; &gt; 大于 &amp;amp; &amp; 和号 &amp;apos; &apos; 单引号 &amp;quot; &quot; 引号 CDATA区CDATA区中的所有内容都会被认为是字符串1&lt;![CDATA[ 内容 ]]&gt; xml解析从xml文档中获取数据 解析方式 DOM解析 Doucument Object Model SAX解析 Simple Api for Xml 两种解析方式的区别DOM: 一次性将文档加载到内存形成树形结构解析 优点:当文件特别大时容易内存溢出 缺点:对xml进行增删改操作 SAX: 事件驱动方式,一行一行的解析 优点:不能对文档进行增删改操作 缺点:当文件特别大时不会内存溢出 api实现与案例针对这两种解析的方式，不同的公司提供了不同的API的实现. JAXP :SUN公司提供的一套XML的解析的API. JDOM :开源组织提供了一套XML的解析的API-jdom. DOM4J :开源组织提供了一套XML的解析的API-dom4j. pull :主要应用在Android手机端解析XML. dom4j案例代码 【步骤一】导入jar包.dom4j-1.6.1.jar 【步骤二】创建解析器 【步骤三】解析文档获得代表文档的Document对象. 【步骤四】获得跟节点. 【步骤五】从跟节点下查找其他的节点 12345678910111213141516// 创建解析器SAXReader reader = new SAXReader();// 解析XML的文档Document document = reader.read("xml/demo1.xml");// 获得跟节点Element root = document.getRootElement();System.out.println(root.getName());// 查找跟节点下的子节点. element() elements();Element pElement = root.element("person"); // 查找的是第一个person元素// root.elements("person").get(1); // 查找的是第二个person元素Element nElement = pElement.element("name");Element aElement = pElement.element("age");Element sElement = pElement.element("sex");System.out.println(nElement.getText());System.out.println(aElement.getText());System.out.println(sElement.getText()); XPathXPath由W3C的XPath 1.0 标准描述,dom4j支持xpath jaxen-1.1-beta-6.jar dom4j的XPath支持的API: List document.selectNodes(String xPath); Node document.selectSingleNode(String xPath);1234567891011121314// 创建解析器: SAXReader reader = new SAXReader(); // 解析XML返回Document对象. Document document = reader.read("xml/demo1.xml"); /*List&lt;Node&gt; list = document.selectNodes("//name"); for (Node node : list) &#123; Element element = (Element) node; System.out.println(element.getText()); &#125;*/ List&lt;Node&gt; list = document.selectNodes("//person['@id']"); for (Node node : list) &#123; Element element = (Element) node; System.out.println(element.attributeValue("id")); &#125; xml约束XML的约束的概述: 什么是XML的约束 :就是用来约束XML的文档中可以出现哪些标签，不能出现哪些标签，标签中是否有顺序，出现的次数. XML的约束 :用来规范XML的写法 ###XML的约束的种类及区别?DTD 和 Schema : 区别: 1.DTD语法是自成一体的.Schema语法就是XML的语法. 2.Schema的语法就是XML的语法所以更容易被解析器所解析. 3.Schema支持名称空间. 4.Schema有比DTD更加强大的语义和语法的约束. DTD的语法####DTD的引入方式: 内部的DTD:&lt;!DOCTYPE persons []&gt; 外部的DTD: 一种本地DTD:&lt;!DOCTYPE persons SYSTEM “unknown.dtd”&gt; 一种网络DTD:&lt;!DOCTYPE persons PUBLIC “//UNKNOWN/“ “unknown.dtd”&gt; 元素: &lt;!ELEMENT 元素名 元素类型&gt; 元素类型: EMPTY ANY 子元素 是否有序: 使用 逗号(,)或者竖线(|)表示. 出现的次数：?:零次或一次 +：一次或多次 *：零次或多次 PCDATA 可解析的字符串 属性: &lt;!ATTLIST 元素名称 属性名称 属性的类型 属性的约束&gt; 属性的类型: ID类型:表示属性值需要是唯一的. CDATA类型:普通的字符串. 枚举: 属性的约束: #REQUIRED 属性值是必须的 #IMPLIED 属性不是必须的 #FIXED value 属性值固定12345678&lt;!ELEMENT persons (person*)&gt;&lt;!ELEMENT person (name|age|sex)*&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT age (#PCDATA)&gt;&lt;!ELEMENT sex (#PCDATA)&gt;&lt;!ATTLIST person id ID #REQUIRED&gt; Schema的语法12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 名称空间:一个XML只能引入一个DTD约束文档.使用了Schema约束XML文档,一个XML可以引入多个Schame的约束!!! 如果再多个Schema文档中定义了相同的属性名称 该怎么办? * 名称空间类似于java中的package.通过名称空间区分 标签或属性来自于哪个文档的！！！通常名称空间唯一的不重复的即可.一般情况下使用一个URL地址表示一个名称空间. xmlns :xml name sapace .代表当前的文档应用的名称空间. targetNameSpace :目标名称空间. elementFormDefault : --&gt;&lt;schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.itheima.com/ee25" elementFormDefault="qualified"&gt; &lt;!-- 复杂标签 --&gt; &lt;element name="persons"&gt; &lt;!-- 复杂类型 --&gt; &lt;complexType&gt; &lt;sequence maxOccurs="unbounded" minOccurs="1"&gt; &lt;element name="person"&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;!-- 简单标签 --&gt; &lt;element name="name" type="string"&gt;&lt;/element&gt; &lt;element name="age" type="int"&gt;&lt;/element&gt; &lt;element name="sex" type="string"&gt;&lt;/element&gt; &lt;/sequence&gt; &lt;attribute name="id" type="string" use="required"/&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt;&lt;/schema&gt;]]></content>
      <categories>
        <category>javaWeb</category>
      </categories>
      <tags>
        <tag>xml</tag>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站主题设置]]></title>
    <url>%2F%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%2F%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[动态背景 修改 _layout.swig 主题文件下/layout/_layout.swig 在 &lt;\/body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面) 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 修改主题配置文件 打开 主题下的_config.yml,在里面添加如下代码：(可以放在最后面)123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 主页文章阴影效果打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 在网站底部加上访问量编辑 主题配置文件 中的busuanzi_count的配置项。 当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。 \themes\next\layout_partials\footer.swig文件,在copyright前加上画红线这句话：1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后添加显示统计的代码123456&lt;!-- 放在&lt;div class=&quot;powered-by&quot;&gt; 前--&gt;&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 首页只显示文章部分 修改 _config.yml文件123auto_excerpt: enable: true length: 150 页脚元素居中修改your blog\themes\next\source\css\schemes\Mist\index.styl文件，将.footer-inner中的text-align: left;修改为text-align: center;即可。 修改文章内链接文本样式修改文件 themes\next\source\css\_common\components\post\post.styl ，在末尾添加如下css样式，： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; blog文章书写开头格式1234567891011title: # 文章标题author: # 作者tags: - Hexo - Nextcategories: - Hexo - Nextdescription: # 描述，首页文章显示的摘要date: --- 关闭侧边栏设置在\source\js\src\motion.js里自行写实现该效果的js方法（当然也可以放在页面其他js文件里面）： 这里贴一个实现此需求的js方法： // $(‘.sidebar-inner’).css({‘height’:’100%’});$(‘body’).on(‘click’,function(e){ var bSidebarShow = $(‘#sidebar’).css(‘display’)===’block’ &amp;&amp; $(‘#sidebar’).width() &gt; 0; var bFlag = $(e.target).parents(‘#sidebar,.sidebar-toggle’).length &gt; 0; if(bSidebarShow &amp;&amp; !bFlag){ $(‘.sidebar-toggle-line-wrap’).trigger(‘click’); e.preventDefault(); }}); 侧边栏居左 修改 source\js\src\motion.js使用Ctrl+F查找paddingRight 把其修改为paddingLeft就可以了 source\css_custom下为custom.styl添加内容123456 .sidebar-toggle&#123; left:30px;&#125;.sidebar&#123; left:0;&#125; 把back-to-top这个按钮留在了右侧如果你偏向一并放在左侧 添加以下css123.back-to-top&#123; left:30px;&#125; 修改箭头动画方向修改motion.js文件123456789101112131415161718192021var sidebarToggleLine1st = new SidebarToggleLine(&#123; el: '.sidebar-toggle-line-first', status: &#123; arrow: &#123;width: '60%', rotateZ: '45deg', top: '2px', left: '50%'&#125;, close: &#123;width: '100%', rotateZ: '-45deg', top: '5px'&#125; &#125;&#125;);var sidebarToggleLine2nd = new SidebarToggleLine(&#123; el: '.sidebar-toggle-line-middle', status: &#123; arrow: &#123;width: '90%'&#125;, close: &#123;opacity: 0&#125; &#125;&#125;);var sidebarToggleLine3rd = new SidebarToggleLine(&#123; el: '.sidebar-toggle-line-last', status: &#123; arrow: &#123;width: '60%', rotateZ: '-45deg', top: '-2px', left: '50%'&#125;, close: &#123;width: '100%', rotateZ: '45deg', top: '-5px'&#125; &#125;&#125;); 不能调整透明就把motion.js中选择的两个body改成了.containerNexT.utils.isDesktop() &amp;&amp; $(‘.container’).velocity(‘stop’) 侧栏背景图以及内部文字颜色的修改在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：1234567#sidebar &#123; background:url(图片链接); background-size: cover; background-position:center; background-repeat:no-repeat; p,span,a &#123;color: 颜色代码;&#125;&#125; 滑动的menumenu中的搜索LocalSearch搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： $ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： Local search local_search: enable: true]]></content>
      <categories>
        <category>网站搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog网站搭建]]></title>
    <url>%2F%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%2F%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[准备 Node.js Git Hexo github账号 安装node.js官网 安装Git直接到Git官网 下载安装即可 安装Hexo 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装好Node.js与Git 执行命令 1npm install -g hexo-cli 初始化随便建一个文件夹，名字随便取，博主取其名为blog，cd 到文件夹里，先安装必要的文件，执行以下命令：12hexo init # hexo会在目标文件夹建立网站所需要的所有文件npm install # 安装依赖包 本地启动有了必要的各种配置文件之后就可以在本地预览效果了12hexo g # 等同于hexo generate，生成静态文件hexo s # 等同于hexo server，在本地服务器运行 打开浏览器并输入IP地址 http://localhost:4000/ 查看 简单的命令总结一下简单的使用命令1234567hexo init [folder] # 初始化一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站hexo new [layout] &lt;title&gt; # 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来hexo version # 查看版本hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g # 等于hexo generate # 生成静态文件hexo s # 等于hexo server # 本地预览hexo d # 等于hexo deploy # 部署，可与hexo g合并为 hexo d -g 安装主题git克隆Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可使用git克隆最新版next主题12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题打开站点配置文件， 找到 theme 字段，并将其值更改为 next1theme: next 然后 hexo s 即可预览主题效果 更换主题外观NexT有三个外观，博主用的是 Muse，直接更改主题配置文件的 scheme 参数即可，如果显示的是繁体中文，那么站点配置文件中的 language: zh-CN123scheme: Muse#scheme: Mist#scheme: Pisces 注册Github部署到Github与Coding在此之前，先安装Git部署插件1npm install hexo-deployer-git --save 打开站点配置文件，拉到底部，修改部署配置：1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:masteranthoneyd/masteranthoneyd.github.io.git,master coding: git@git.coding.net:ookamiantd/ookamiantd.git,master 终端执行123hexo cleanhexo ghexo d 绑定域名]]></content>
      <categories>
        <category>网站搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
